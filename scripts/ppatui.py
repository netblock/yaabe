#!/usr/bin/env python
# -*- coding: utf-8 -*-

# A metaprogramming script that consumes json5 files to produce c source files
# and c header files for atomtree ATUI.
# see atomtree/atui_tables/atui_documentation.md for more info on ATUI.

# To generate C source files branches:
# ppatui.py -s -o output.c -i input.json5
# Produce header files of the generated functions:
# ppatui.py -d -o output.h -i input.json5

# To generate header files for the enums:
# ppatui.py -d -o output.h -i input.json5

import sys
import copy
import json5
import pathlib
import argparse

ATUI_NOFANCY   = 0
ATUI_BITFIELD  = 1
ATUI_ENUM      = 2
ATUI_STRING    = 3
ATUI_ARRAY     = 4
ATUI_GRAFT     = 5
ATUI_SHOOT     = 6
ATUI_DYNARRAY  = 7
_ATUI_BITCHILD = 8

ATUI_FANCY_TYPES = (
	"ATUI_NOFANCY",
	"ATUI_BITFIELD",
	"ATUI_ENUM",
	"ATUI_STRING",
	"ATUI_ARRAY",
	"ATUI_GRAFT",
	"ATUI_SHOOT",
	"ATUI_DYNARRAY",
	"_ATUI_BITCHILD",
)

def description_to_text(
		description:dict,
		indent:str
		):
	# description segment meant for a segment of a c file
	if (description is None):
		return ""
	lang_type = ""
	languages = ("english",)
	descriptions = [None,]
	descr_index = 0
	for trans in description:
		descr_index = languages.index(trans["language"])
		descriptions[descr_index] = trans["text"]

	child_indent = indent + "\t"
	descr_template = (
indent + ".description = {\n"
+ "%s"
+ indent + "},\n"
	)

	des_entry_template = child_indent + "u8\"%s\",\n"
	des_null_entry_template = child_indent + "NULL,\n"

	descr_texts = ""
	for d in descriptions:
		if d:
			descr_texts += des_entry_template % d.replace("\"","\\\"")
		else:
			descr_texts += des_null_entry_template
	return descr_template % descr_texts


def searchfield_to_h(
		atui_data:dict,
		fname:str
		):
	assert(atui_data["class"] == "searchfield")
	header_header = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

"""
	field_template = "extern struct register_set const %s_reg_set;\n"
	header_end = "\n#endif\n"
	out_text = header_header % (fname.upper(), fname.upper())
	for field in atui_data["fields"]:
		out_text += field_template % field["name"]
	return out_text + header_end
def searchfield_to_c(
		atui_data:dict,
		fname:str
		):
	assert(atui_data["class"] == "searchfield")
	cfile_header = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "atomtree.h"

"""
	field_template = """\
struct register_set const %s_reg_set = {
	.num_reg_set_addresses = %u,
	.set_name = u8"%s",
	.entries = (struct register_set_entry const[%u]) {
%s\
	},
};
static_assert(%u < INT16_MAX); // reserve sign as flag for register_set_bsearch

"""
	field_entry = """\t\t{.address=%s, .name=u8"%s"},\n"""
	out_text = cfile_header
	entry_text = ""
	num_constants = 0
	for field in atui_data["fields"]:
		entry_text = ""
		for entry in field["constants"]:
			entry_text += field_entry % (entry, entry)
		num_constants = len(field["constants"])
		out_text += field_template % (
			field["name"],
			num_constants, field["name"], len(field["constants"]),
			entry_text,
			num_constants, # assert
		)
	return out_text



def array_to_h(
		atui_data:dict,
		fname:str
		):
	assert(atui_data["class"] == "array")
	header_header = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

"""
	array_template = "extern %s const %s[%u];\n"
	header_end = "\n#endif\n"
	out_text = header_header % (fname.upper(), fname.upper())
	for array in atui_data["arrays"]:
		out_text += array_template % (
			array["type"], array["name"], len(array["constants"])
		)
	return out_text + header_end
def array_to_c(
		atui_data:dict,
		fname:str
		):
	assert(atui_data["class"] == "array")
	cfile_header = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "atomtree.h"

"""
	array_template = """\
%s const %s[%u] = {
%s\
};

"""
	array_entry = "\t%s,\n"
	out_text = cfile_header
	entry_text = ""
	for array in atui_data["arrays"]:
		entry_text = ""
		for entry in array["constants"]:
			entry_text += array_entry % entry
		out_text += array_template % (
			array["type"], array["name"], len(array["constants"]),
			entry_text
		)
	return out_text


def enum_to_h(
		atui_data:dict,
		fname:str
		):
	assert(atui_data["class"] == "enum")
	header_header = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

extern struct atui_enum const _atui_enumarray[%u];

"""
	enumarray_indicies_set_template = """\
enum enumarray_indicies_set {
%s\
	ATUI_ENUM_ARRAY_LENGTH
};
"""
	enum_index_entry_template = "\tATUI_ENUM_INDEX(%s) = %u,\n"
	header_end = "\n#endif\n"

	enums = atui_data["enums"]
	num_enums = len(enums)

	i = 0
	indicies = ""
	while i < num_enums:
		enum = enums[i]
		indicies += enum_index_entry_template % (enum["name"], i)
		i += 1

	out_text = (
		header_header % (fname.upper(), fname.upper(), num_enums)
		+ enumarray_indicies_set_template % indicies
		+ header_end
	)
	return out_text

def enum_to_c(
		atui_data:dict,
		fname:str
		):
	assert(atui_data["class"] == "enum")
	cfile_header = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "atomtree.h"
#include "atui.h"

"""
	enumarray_template = """\
struct atui_enum const _atui_enumarray[%u] = {
%s\
};

"""
	enum_template = """\
	{
		.name_length = %u,
		.name = u8"%s",
		.num_entries = %u,
%s\
		.enum_array = (struct atui_enum_entry const[%u]) {
%s\
		},
	},
"""
	enum_entry_template = """\
			{
				.name = u8\"%s\",
				.val = %s,
				.name_length = %u,
%s\
			},
"""
	enum_entry_assert_template = """\
"""
	enum_assert_template = """\
static_assert(UINT8_MAX >= ATUI_ENUM(%s).num_entries);
"""

	# main meat
	enum_sets = "" # _atui_enumarray members
	enum_entries = "" #  struct atui_enum_entry
	entry_name = ""
	descr_text = ""
	for enum in atui_data["enums"]:
		enum_entries = ""
		enum_entries_asserts = ""
		for entry in enum["constants"]:
			entry_name = entry["name"]
			#out_text += enum_entry_assert_template % entry_name
			if "description" in entry:
				descr_text = description_to_text(
					entry["description"], "\t\t\t\t"
				)
			else:
				descr_text = ""
			enum_entries += enum_entry_template % (
				entry_name, entry_name, len(entry_name), descr_text
			)

		if "description" in enum:
			descr_text = description_to_text(enum["description"], "\t\t")
		else:
			descr_text = ""
		enum_sets += enum_template % (
			len(enum["name"]), enum["name"], len(enum["constants"]),
			descr_text,
			len(enum["constants"]),
			enum_entries
		)

	#asserts
	enum_asserts = ""
	enum_entries_asserts = ""
	#for enum in atui_data["enums"]:
	#	enum_asserts += enum_assert_template % enum["name"]

	out_text = (
		cfile_header
		+ enumarray_template % (len(atui_data["enums"]), enum_sets)
		+ enum_asserts
	)
	return out_text



class atui_leaf:
	default_type:str  # for defaults; meta
	parent_is_leaf:bool # parent type; meta

	access:str # var
	access_meta:str # for c preprocessor stuff
	name:str
	display:str
	fancy:str
	fancy_data:None #dict, str, list
	description:dict
	lo:str # bitfield children
	hi:str

	def copy(self):
		return copy.copy(self)

	def __init__(self,
			leaf:dict
			):
		self.parent_is_leaf = False
		leafkeys = set(leaf)

		if "default_type" in leafkeys:
			self.default_type = leaf["default_type"]
		else:
			self.default_type = None

		if "access" in leafkeys:
			self.access = leaf["access"]
			self.access_meta = leaf["access"]
		else:
			self.access = None
			self.access_meta = None
		if "name" in leafkeys:
			self.name = leaf["name"]
		else:
			self.name = None
		if "display" in leafkeys:
			self.display = leaf["display"]
		else:
			self.display = None
		if "fancy" in leafkeys:
			self.fancy = ATUI_FANCY_TYPES.index(leaf["fancy"])
		else:
			self.fancy = None
		if "fancy_data" in leafkeys:
			self.fancy_data = leaf["fancy_data"]
		else:
			self.fancy_data = None
		if "description" in leafkeys:
			self.description = leaf["description"]
		else:
			self.description = None
		if "lo" in leafkeys:
			self.lo = leaf["lo"]
		else:
			self.lo = None
		if "hi" in leafkeys:
			self.hi = leaf["hi"]
		else:
			self.hi = None


class atui_branch:
	#parent_is_leaf:bool # would only exist for inline, but that needs to be
	# runtime

	c_prefix:str
	c_type:str
	atomtree:str
	name:str
	description:dict
	leaves:list

	def copy(self):
		return copy.copy(self)

	def __init__(self,
			branch:dict
			):
		branchkeys = set(branch)
		if "c_prefix" in branchkeys:
			self.c_prefix = branch["c_prefix"]
		else:
			self.c_prefix = None
		if "c_type" in branchkeys:
			self.c_type = branch["c_type"]
		else:
			self.c_type = None
		if "atomtree" in branchkeys:
			self.atomtree = branch["atomtree"]
		else:
			self.atomtree = None
		if "name" in branchkeys:
			self.name = branch["name"]
		else:
			self.name = None
		if "description" in branchkeys:
			self.description = branch["description"]
		else:
			self.description = None
		if "table_start" in branchkeys:
			self.table_start = branch["table_start"]
		else:
			self.table_start = None
		if "table_size" in branchkeys:
			self.table_size = branch["table_size"]
		else:
			self.table_size = None

		if "leaves" in branchkeys:
			self.leaves = []
			for leaf in branch["leaves"]:
				self.leaves.append(atui_leaf(leaf))
		else:
			self.leaves = None


def populate_branch_defaults(
		defaults:dict
		):
	# defaults may not explicitly have every intended attribute, so make them
	# exist with NoneType
	default_leaf_types = set(("generic", "bitchild", "dynpattern"))
	leaves = {}
	if "leaf_defaults" in defaults:
		leaves = defaults["leaf_defaults"]
		for leaf in leaves:
			default_leaf_types.remove(leaf)
	else:
		defaults["leaf_defaults"] = leaves
	for name in default_leaf_types:
		leaves[name] = {}

	if not ("branch_defaults" in defaults):
		defaults["branch_defaults"] = {}

	classed_leaves = {}
	for leaf in leaves:
		classed_leaves[leaf] = atui_leaf(leaves[leaf])
	classed_defaults = {
		"branch_defaults": atui_branch(defaults["branch_defaults"]),
		"leaf_defaults": classed_leaves
	}
	return classed_defaults

def infer_leaf_data(
		defaults:dict,
		leaf_select:str,
		leaves:list
		):
	# infer missing data on a branch's leaves based on what already exists for
	# a leaf, and the global_defaults

	leaf_defaults = defaults["leaf_defaults"]
	leaf_default = leaf_defaults[leaf_select]

	for leaf in leaves:
		assert (not (leaf.name is None))

		leaf.parent_is_leaf = leaf_default.parent_is_leaf

		if leaf.access is None:
			leaf.access = leaf_default.access
		if leaf.access_meta is None:
			leaf.access_meta = leaf_default.access_meta
		if leaf.display is None:
			leaf.display = leaf_default.display
		if leaf.fancy is None:
			leaf.fancy = leaf_default.fancy
		if leaf.fancy_data is None:
			leaf.fancy_data = leaf_default.fancy_data
		if leaf.description is None:
			leaf.description = leaf_default.description
		if leaf.lo is None:
			leaf.lo = leaf_default.lo
		if leaf.hi is None:
			leaf.hi = leaf_default.hi

		fancy_data = None
		old_default = None
		child_leaf = None
		access = ""
		access_meta = ""
		if leaf.fancy == ATUI_BITFIELD:
			fancy_data = copy.copy(leaf.fancy_data)
			leaf.fancy_data = []
			for l in fancy_data:
				 leaf.fancy_data.append(atui_leaf(l))

			old_default = leaf_defaults["bitchild"]
			new_default = old_default.copy()
			leaf_defaults["bitchild"] = new_default
			#new_default.access = leaf.access # unnecessary
			new_default.access_meta = leaf.access_meta # c preprocessor stuff
			new_default.fancy = _ATUI_BITCHILD
			new_default.parent_is_leaf = True
			infer_leaf_data(defaults, "bitchild", leaf.fancy_data)

			leaf_defaults["bitchild"] = old_default
		elif leaf.fancy == ATUI_DYNARRAY:
			fancy_data = copy.copy(leaf.fancy_data)
			pattern = []
			leaf.fancy_data["pattern"] = pattern
			for l in fancy_data["pattern"]:
				 pattern.append(atui_leaf(l))

			if not ("enum" in leaf.fancy_data):
				leaf.fancy_data["enum"] = "NULL"
			if leaf.access:
				access_meta = leaf.access_meta # direct array
			else:
				access_meta = fancy_data["deferred"] # array of pointers
			access_meta += "[0]" # c preprocessor stuff

			old_default = leaf_defaults["dynpattern"]
			new_default = old_default.copy()
			leaf_defaults["dynpattern"] = new_default
			new_default.access_meta = access_meta
			new_default.parent_is_leaf = True
			infer_leaf_data(defaults, "dynpattern", pattern)

			leaf_defaults["dynpattern"] = old_default


def infer_branch_data(
		defaults:dict,
		branch:atui_branch,
		infer_leaves:bool=True
		):
	# infer missing data on both the branch elements and all of its leaves,
	# based on what already exists for that branch, and the global_defaults

	branch_defaults = defaults["branch_defaults"]

	if branch.c_prefix is None:
		branch.c_prefix = branch_defaults.c_prefix
	if branch.c_type is None:
		branch.c_type = branch_defaults.c_type
	if branch.atomtree is None:
		branch.atomtree = branch_defaults.atomtree
	if branch.description is None:
		branch.description = branch_defaults.description
	if branch.table_start is None:
		branch.table_start = branch_defaults.table_start
	if branch.table_size is None:
		branch.table_size = branch_defaults.table_size

	assert (not (branch.c_type is None))
	if branch.name is None:
		branch.name = branch.c_type

	if infer_leaves and branch.leaves:
		infer_leaf_data(defaults, "generic", branch.leaves)


def leaf_to_subleaf(
		leaf:atui_leaf,
		indent:str
		):
	# if a leaf has sub leaves. See also: struct subleaf_meta
	child_indent = indent + "\t"
	bounds_template = (
"{\n"
+ child_indent + ".element_size = %s,\n"
+ child_indent + ".dynarray_length = %s,\n"
+ child_indent + ".deferred_start_array = %s,\n"
+ child_indent + ".numleaves = %u,\n"
+ child_indent + ".enum_taglist = %s,\n"
+ child_indent + ".sub_leaves = (atui_leaf const[%u]) {\n"
+ "%s"
+ child_indent + "},\n"
+ indent + "},"
)
	bounds_vals = ()
	if leaf.fancy == ATUI_DYNARRAY:
		access_meta = ""
		if leaf.access_meta:
			access_meta = leaf.access_meta # direct array
		else:
			access_meta = leaf.fancy_data["deferred"]+"[0]" # array of pointers
		if leaf.fancy_data["enum"] == "ATUI_NULL":
			enum_taglist = "NULL"
		else:
			enum_taglist = "&(ATUI_ENUM(%s))" % leaf.fancy_data["enum"]
		bounds_vals = (
			"sizeof(%s[0])" % access_meta,
			leaf.fancy_data["count"],
			str(not leaf.access_meta).lower(),
			len(leaf.fancy_data["pattern"]),
			enum_taglist,
			len(leaf.fancy_data["pattern"]),
			leaves_to_text(leaf.fancy_data["pattern"], child_indent+"\t")
		)
	elif leaf.fancy == ATUI_BITFIELD:
		bounds_vals = (
			"0", "0", "0",
			len(leaf.fancy_data),
			"NULL",
			len(leaf.fancy_data),
			leaves_to_text(leaf.fancy_data, child_indent+"\t"),
		)

	return bounds_template % bounds_vals

def leaf_type_to_text(
		leaftype:list,
		leaf:atui_leaf,
		var_meta:str
		):
	# leaftype : [radix, signed_num, fraction, fancy, disable]
	leaftype[0] = ""
	leaftype[1] = "_PPATUI_LEAF_SIGNED(%s)" % var_meta
	leaftype[2] = "_PPATUI_LEAF_FRACTION(%s)" % var_meta
	leaftype[3] = ATUI_FANCY_TYPES[leaf.fancy]
	leaftype[4] = "ATUI_DISPLAY"

	if type(leaf.display) is str:
		if leaf.display in ("ATUI_SUBONLY", "ATUI_NODISPLAY"):
			leaftype[0] = "ATUI_NAN"
			leaftype[4] = leaf.display
		else:
			leaftype[0] = leaf.display
	elif type(leaf.display) is list:
		if "ATUI_SIGNED" in leaf.display:
			leaftype[1] = "true"
		for radix in ("ATUI_NAN", "ATUI_DEC", "ATUI_HEX", "ATUI_BIN"):
			if radix in leaf.display:
				leaftype[0] = radix
				break
		for disable in ("ATUI_DISPLAY", "ATUI_SUBONLY", "ATUI_NODISPLAY"):
			if disable in leaf.display:
				leaftype[4] = disable
				break

def leaves_to_text(
		leaves:list,
		indent:str
		):
	# leaves to text meant for a segment of a c file
	child_indent = indent + "\t"
	leaf_template = (
indent + "{\n"
+ child_indent + ".name = u8\"%s\",\n"
+ child_indent + ".origname = u8\"%s\",\n"

+ child_indent + ".type.radix = %s,\n"
+ child_indent + ".type.signed_num = %s,\n"
+ child_indent + ".type.fraction = %s,\n"
+ child_indent + ".type.fancy = %s,\n"
+ child_indent + ".type.disable = %s,\n"

+ child_indent + ".num_bytes = _PPATUI_NULLPTR_SIZE(%s),\n"
+ child_indent + ".array_size = 1,\n"
+ child_indent + ".fractional_bits = _PPATUI_LEAF_FIXED_FRACTION_BITS(%s),\n"
+ child_indent + ".total_bits = _PPATUI_LEAF_BITNESS(%s),\n"
+ child_indent + ".bitfield_hi = _PPATUI_LEAF_BITNESS(%s) - 1,\n"
+ child_indent + ".val = %s,\n"

+ "%s"
+ indent + "},\n"
)

	leaf_text_extra = "" # if there is any extra leaf elements
	var_meta = ""
	leaves_text = ""

	leaftype = ["radix","signed_num","fraction","fancy","disable"]

	for leaf in leaves:
		if leaf.access:
			var_access = "&(%s)" % leaf.access
		else:
			var_access = "NULL"
		if leaf.access_meta:
			var_meta = leaf.access_meta
		else:
			var_meta = "NULL"

		if leaf.fancy == ATUI_NOFANCY:
			leaf_text_extra = ""
		elif leaf.fancy == ATUI_ENUM:
			leaf_text_extra = (
				child_indent + ".enum_options = &(ATUI_ENUM(%s)),\n"
			)
			leaf_text_extra %= (leaf.fancy_data,)
		elif leaf.fancy == ATUI_STRING:
			if leaf.access:
				var_access = leaf.access
			leaf_text_extra = ""
		elif leaf.fancy == ATUI_ARRAY:
			if leaf.access:
				var_access = leaf.access
			var_meta = leaf.access_meta + "[0]"
			leaf_text_extra = (
				child_indent + ".array_size = (sizeof(%s)/sizeof(%s)),\n"
				+ child_indent + ".num_bytes = sizeof(%s),\n"
			)
			leaf_text_extra %= (leaf.access, var_meta, leaf.access)
		elif leaf.fancy == ATUI_BITFIELD:
			leaf_text_extra = (
				child_indent + ".num_child_leaves = %u,\n"
				+ child_indent +
					".template_leaves = & (struct subleaf_meta const) %s\n"
			)
			leaf_text_extra %= (
				len(leaf.fancy_data),
				leaf_to_subleaf(leaf, child_indent),
			)
		elif leaf.fancy == _ATUI_BITCHILD:
			leaf_text_extra = (
				child_indent + ".bitfield_hi = %u,\n"
				+ child_indent + ".bitfield_lo = %u,\n"
			)
			leaf_text_extra %= (leaf.hi, leaf.lo)
		elif leaf.fancy in (ATUI_SHOOT, ATUI_GRAFT):
			leaf_text_extra = (
				child_indent + ".branch_bud = ATUI_FUNC(%s),\n"
			)
			leaf_text_extra %= (leaf.fancy_data,)
		elif leaf.fancy == ATUI_DYNARRAY:
			if leaf.access:
				var_access = leaf.access
				var_meta = leaf.access_meta + "[0]"
			else:
				var_access = leaf.fancy_data["deferred"]
			if leaf.access_meta:
				var_meta = leaf.access_meta + "[0]"
			else:
				var_meta = leaf.fancy_data["deferred"] + "[0]"
			leaf_text_extra = (
				child_indent +
					".template_leaves = & (struct subleaf_meta const) %s\n"
			)
			leaf_text_extra %= (leaf_to_subleaf(leaf, child_indent),)
		else:
			assert 0, leaf.fancy

		leaf_text_extra += description_to_text(leaf.description, child_indent)
		if leaf.parent_is_leaf:
			leaf_text_extra += child_indent + ".parent_is_leaf = true,\n"
		leaf.name = leaf.name.replace("\"","\\\"")

		leaf_type_to_text(leaftype, leaf, var_meta)

		leaves_text += leaf_template % (
			leaf.name, leaf.name,
			leaftype[0], leaftype[1], leaftype[2], leaftype[3], leaftype[4],
			var_meta, var_meta, var_meta, var_meta,  var_access,
			leaf_text_extra
		)
	return leaves_text


def deep_count_leaves(
		counters: list,
		leaves:list,
		counters_template:list
		):
	# go through all the leaves, recursively, to develop a string

	#counters_template = [0 for i in range(6)]
	#for i in range(1,6,2): counters_template[i] = "0"

	# 0: non-dynarray-pattern leaves
	# 1: dynarray leaves
	# 2: inline
	# 3: dynarray inline
	# 4: petiole
	# 5: dynarray petiole
	nest_dynarray = "+ (%s * (%u + %s))"
	sub_counters = []
	dynlength = ""
	counters[0] += len(leaves)
	for leaf in leaves:
		if leaf.fancy == ATUI_GRAFT:
			counters[2] += 1
		elif leaf.fancy == ATUI_SHOOT:
			counters[4] += 1
		#elif leaf.fancy == ATUI_BITFIELD:
		#	counters[0] += len(leaf.fancy_data)
		elif leaf.fancy == ATUI_DYNARRAY:
			sub_counters = counters_template.copy()
			# We're in dynarray. The dynarray segments of subcounters  will be
			# non-'0' if there is a nested dynarray.
			dynlength = leaf.fancy_data["count"]
			deep_count_leaves(
				sub_counters, leaf.fancy_data["pattern"],  counters_template
			)
			counters[1] += nest_dynarray % (
				dynlength, sub_counters[0], sub_counters[1]
			)
			counters[3] += nest_dynarray % (
				dynlength, sub_counters[2], sub_counters[3]
			)
			counters[5] += nest_dynarray % (
				dynlength, sub_counters[4], sub_counters[5]
			)



def branches_to_c(
		atui_data:dict,
		fname:str
		):
	# atui branches to text meant for a c file
	assert(atui_data["class"] == "branch")
	assert(type(atui_data["branches"]) is list)

	branches = []
	branch = None
	defaults = populate_branch_defaults(atui_data["global_default"])
	for bd in atui_data["branches"]:
		branch = atui_branch(bd)
		infer_branch_data(defaults, branch, True)
		branches.append(branch)

	cfile_header = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "atomtree.h"
#include "atui.h"
"""
# These arrays need to be in a function to handle the bios-> and atomtree->
# everywhere. trying to globalise the vars gets annoying real fast.
	branch_template = """
PPATUI_HEADERIFY(%s) {
	%s %s const* const bios = args->suggestbios;
	struct %s const* const atomtree = args->atomtree;

	atui_leaf const leaves_init[%u] = {
%s\
	};
	struct atui_branch_data const branch_embryo = {
		.origname = u8"%s",
%s\
		.table_start = (void*) (%s),
		.table_size = (%s),
		.sizeofbios = _PPATUI_NULLPTR_SIZE(*bios),
		.leaves_init = leaves_init,
		.num_leaves_init = lengthof(leaves_init),
		.computed_num_leaves = %s,
		.computed_num_inline = %s,
		.computed_num_petiole = %s,
	};

	assert(branch_embryo.num_leaves_init < UINT16_MAX);
	assert(branch_embryo.computed_num_leaves < UINT16_MAX);
	assert(branch_embryo.computed_num_inline < UINT8_MAX);
	assert(branch_embryo.computed_num_petiole < UINT8_MAX);

	static_assert(sizeof(u8"%s") <= sizeof(((atui_branch*)0)->name));

	return atui_branch_allocator(&branch_embryo, args);
}
"""

	dynarray_patterns_text = ""
	dynarray_bounds_text = ""
	num_inline = 0
	num_petiole = 0

	# for deep count
	counters_template = [0 for i in range(6)]
	for i in range(1,6,2): counters_template[i] = "0" # 3 pairs of 0,""
	counters = []

	out_text = cfile_header
	for branch in branches:
		counters = counters_template.copy()
		deep_count_leaves(counters, branch.leaves, counters_template)

		out_text += branch_template % (
			branch.name, branch.c_prefix, branch.c_type, branch.atomtree,
			len(branch.leaves), leaves_to_text(branch.leaves, "\t\t"),
			branch.name, # embryo
			description_to_text(branch.description, "\t\t"),
			branch.table_start, branch.table_size,
			"(%u + %s)" % (counters[0], counters[1]),
			"(%u + %s)" % (counters[2], counters[3]),
			"(%u + %s)" % (counters[4], counters[5]),
			branch.name, # assert
		)
	return out_text


def branches_to_h(
		atui_data:dict,
		fname:str
		):
	# c header defines from atui branches
	assert(atui_data["class"] == "branch")
	assert(type(atui_data["branches"]) is list)

	header_header = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

"""
	header_entry = "PPATUI_HEADERIFY(%s);\n"
	header_ender = "\n#endif\n"

	out_text = header_header % (fname.upper(), fname.upper())
	branch = None
	defaults = populate_branch_defaults(atui_data["global_default"])
	for bd in atui_data["branches"]:
		branch = atui_branch(bd)
		infer_branch_data(defaults, branch, False)
		out_text += header_entry % branch.name

	return out_text + header_ender


def parse_args(
		argv:list
		):
	parser = argparse.ArgumentParser()
	parser.add_argument("-o", "--output", required=True, nargs=1)
	parser.add_argument("-i", "--inputs", required=True, nargs='*')
	modes = parser.add_mutually_exclusive_group(required=True)
	modes.add_argument("-s", "--source", action="store_true")
	modes.add_argument("-d", "--header", action="store_true")
	return parser.parse_args(argv)
def intend_source(
		atui_data:dict
		):
	assert("class" in atui_data)
	match (atui_data["class"]):
		case "branch": return branches_to_c
		case "enum": return enum_to_c
		case "array": return array_to_c
		case "searchfield": return searchfield_to_c
		case _: assert 0
def intend_header(
		atui_data:dict
		):
	assert("class" in atui_data)
	match (atui_data["class"]):
		case "branch": return branches_to_h
		case "enum": return enum_to_h
		case "array": return array_to_h
		case "searchfield": return searchfield_to_h
		case _: assert 0
def get_intent( # cli argument handling
		intent:argparse.Namespace
		):
	if intent.source:
		return intend_source
	elif intent.header:
		return intend_header
	else:
		assert 0

def main(
		argc:int,
		argv:list
		):
	args = parse_args(argv[1:])

	# a function call that returns a function to select which final function to
	# use
	get_mode = get_intent(args)
	atui_data = {}
	output_text = ""
	for infile in args.inputs:
		with open(infile, 'r', encoding="utf-8") as f:
			atui_data = json5.load(f)
		mode_func = get_mode(atui_data)
		output_text += mode_func(atui_data, pathlib.Path(infile).stem)

	with open(args.output[0], 'w', encoding="utf-8") as f:
		f.write(output_text)

if (__name__ == "__main__"):
	sys.exit(main(len(sys.argv), sys.argv))
