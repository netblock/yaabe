#!/usr/bin/env python
# -*- coding: utf-8 -*-

# A metaprogramming script that consumes json5 files to produce c source files
# and c header files for atomtree, usually specifically for ATUI.
# see atomtree/atui_tables/README.md for more info on what the inputs are about
# see also atomtree/atui/atui.h and atomtree/atui/ppatui.h

# To generate C source files branches:
# ppatui.py -s -o output.c -i input.json5
# Produce header files of the generated functions:
# ppatui.py -d -o output.h -i input.json5

# To generate header files for the enums:
# ppatui.py -d -o output.h -i input.json5

import sys
import copy
import json5
import pathlib
import argparse
from typing import Callable

def pcilut_to_c(
		atui_data:dict,
		fname:str
		) -> str:
	# see atomtree/pci_id_lut.h
	assert (atui_data["class"] == "pci_id_lut"), fname

	unique_ids:set = set()
	card:dict
	for card in atui_data["ids"]:
		part_id:int = ((card["vendor"]<<16) | card["device"])
		# we really shouldn't have two identical cards
		assert (part_id not in unique_ids), part_id
		unique_ids.add(part_id)
	del unique_ids
	pci_id_sorter:function = lambda card: ((card["vendor"]<<16)|card["device"])
	atui_data["ids"].sort(key=pci_id_sorter)

	cfile_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "standard.h"
#include "pci_id_lut.h"

struct atomtree_pci_id const %s[%u] = {
%s\
};
static_assert(%u < INT16_MAX); // reserve sign as flag for register_set_bsearch
"""
	entry_template:str = """\
	{
		.ids.vendor = 0x%04X, .ids.device = 0x%04X, .chip = %s,
%s\
	},
"""
	feature_flags:dict = {
		"MOBILITY":     "\t\t.flags.mobility = true,\n",
		"APU":          "\t\t.flags.APU = true,\n",
		"ACPI_ATPX":    "\t\t.flags.ACPI_ATPX = true,\n",
		"EXPERIMENTAL": "\t\t.flags.experimental_hw = true,\n",
		"SINGLE_CRTC":  "\t\t.flags.single_CRTC = true,\n",
		"AGP":          "\t\t.flags.AGP = true,\n",
		"IGPGART":      "\t\t.flags.igpgart = true,\n",
		"PCIe":         "\t\t.flags.PCIe = true,\n",
		"NEW_MEMMAP":   "\t\t.flags.new_memmap = true,\n",
		"PCI":          "\t\t.flags.PCI = true,\n",
	}
	entries_text:str = ""
	card:dict
	for card in atui_data["ids"]:
		flags_text:str = ""
		if "flags" in card:
			flag:str
			for flag in card["flags"]:
				flags_text += feature_flags[flag]
		entries_text += entry_template % (
			card["vendor"], card["device"], card["chip"],
			flags_text
		)
	out_text:str = cfile_header % (
		fname.lower(), len(atui_data["ids"]),
		entries_text,
		len(atui_data["ids"]),
	)
	return out_text
def pcilut_to_h(
		atui_data:dict,
		fname:str
		) -> str:
	assert (atui_data["class"] == "pci_id_lut"), fname
	header_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H
extern struct atomtree_pci_id const %s[%u];
#endif
"""
	out_text:str = header_header % (
		fname.upper(), fname.upper(),
		fname.lower(), len(atui_data["ids"]),
	)
	return out_text


def description_to_text(
		description:dict,
		parent_indent:str
		) -> str:
	# language codes follow ISO 639-3
	# description segment meant for a segment of a c file
	#indended to be used like
	# ".description = {%s}" % description_to_text(...)
	if (description is None):
		return ""
	lang_type:str = ""
	languages:tuple = ("eng",)
	descriptions:list = [None,] * len(languages)
	descr_index:int = 0
	trans:dict 
	for trans in description:
		descr_index:int = languages.index(trans)
		descriptions[descr_index]:str = description[trans]
 
	indent:str = parent_indent + "\t"
	descr_template:str = "\n%s" + parent_indent

	des_entry_template:str = indent + "\"%s\",\n"
	des_null_entry_template:str = indent + "NULL,\n"

	descr_texts:str = ""
	d:str
	for d in descriptions:
		if d:
			descr_texts += des_entry_template % d.replace("\"","\\\"")
		else:
			descr_texts += des_null_entry_template
	return descr_template % descr_texts


def searchfield_to_h(
		atui_data:dict,
		fname:str
		) -> str:
	assert(atui_data["class"] == "searchfield"), fname
	header_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

"""
	field_template:str = "extern struct register_set const %s_reg_set;\n"
	header_end:str = "\n#endif\n"
	out_text:str = header_header % (fname.upper(), fname.upper())
	field:dict
	for field in atui_data["fields"]:
		out_text += field_template % field["name"]
	return out_text + header_end
def searchfield_to_c(
		atui_data:dict,
		fname:str
		) -> str:
	assert(atui_data["class"] == "searchfield"), fname
	cfile_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "standard.h"
#include "atomtree.h"
#include "atui.h"
#include "atui_allocator.h"

"""
	field_template:str = """\
struct register_set const %s_reg_set = {
	.num_reg_set_addresses = %u,
	.set_name = "%s",
	.entries = {
%s\
	},
};
static_assert(%u < INT16_MAX); // reserve sign as flag for register_set_bsearch

"""
	field_entry:str = """\
		{
			.address = %s,
			.index_name = "%s",
			.field_name = "%s",
			.atui_branch_func = _atui_%s,
		},
"""
	out_text:str = cfile_header
	entry_text:str = ""
	num_constants:int = 0
	field:dict
	for field in atui_data["fields"]:
		entry_text:str = ""
		entry:dict
		for entry in field["registers"]:
			index_name:str = entry["index"]
			field_name:str = entry["field"]
			entry_text += field_entry % (
				index_name, index_name,  field_name, field_name
			)
		num_constants:int = len(field["registers"])
		out_text += field_template % (
			field["name"],
			num_constants, field["name"],
			entry_text,
			num_constants, # assert
		)
	return out_text


def array_to_h(
		atui_data:dict,
		fname:str
		) -> str:
	assert (atui_data["class"] == "array"), fname
	header_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

"""
	array_template:str = "extern %s const %s[%u];\n"
	header_end:str = "\n#endif\n"
	out_text:str = header_header % (fname.upper(), fname.upper())
	array:dict
	for array in atui_data["arrays"]:
		out_text += array_template % (
			array["type"], array["name"], len(array["constants"])
		)
	return out_text + header_end
def array_to_c(
		atui_data:dict,
		fname:str
		) -> str:
	assert (atui_data["class"] == "array"), fname
	cfile_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "standard.h"
#include "atomtree.h"

"""
	array_template = """\
%s const %s[%u] = {
%s\
};

"""
	array_entry:str = "\t%s,\n"
	out_text:str = cfile_header
	entry_text:str = ""
	array:dict
	for array in atui_data["arrays"]:
		entry_text:str = ""
		entry:dict
		for entry in array["constants"]:
			entry_text += array_entry % entry
		out_text += array_template % (
			array["type"], array["name"], len(array["constants"]),
			entry_text
		)
	return out_text


def enum_to_h(
		atui_data:dict,
		fname:str
		) -> str:
	assert (atui_data["class"] == "enum"), fname
	header_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

extern struct atui_enum const _atui_enumarray[%u];

"""
	enumarray_indicies_set_template:str = """\
enum enumarray_indicies_set {
%s\
	ATUI_ENUM_ARRAY_LENGTH
};
"""
	enum_index_entry_template:str = "\tATUI_ENUM_INDEX(%s) = %u,\n"
	enum_infer_template:str = """
// cannot be used with non-enums types
#define ATUI_ENUM_INFER(var) _Generic((var),\\
%s\
	default: NULL\\
)
"""
	enum_infer_entry_template:str = "\tenum %s: & ATUI_ENUM(%s),\\\n"
	enum_indexof_template:str = """
// cannot be used with non-enums types
#define ATUI_ENUM_INDEXOF(var) _Generic((var),\\
%s\
	default: ATUI_ENUM_ARRAY_LENGTH\\
)
"""
	enum_indexof_entry_template:str = "\tenum %s: ATUI_ENUM_INDEX(%s),\\\n"
	header_end:str = "\n#endif\n"

	enums:list = atui_data["enums"]
	num_enums:int = len(enums)

	i:int = 0
	indicies:str = ""
	infers:str = ""
	indexofs:str = ""
	while i < num_enums:
		enum:dict = enums[i]
		enum_name:str = enum["name"]
		indicies += enum_index_entry_template % (enum_name, i)
		infers += enum_infer_entry_template % (enum_name, enum_name)
		indexofs +=  enum_indexof_entry_template % (enum_name, enum_name)
		if "aliases" in enum:
			alias:str
			for alias in enum["aliases"]:
				indicies += enum_index_entry_template % (alias, i)
				infers += enum_infer_entry_template % (alias, alias)
				indexofs +=  enum_indexof_entry_template % (alias, alias)
		i += 1

	out_text = (
		header_header % (fname.upper(), fname.upper(), num_enums)
		+ enumarray_indicies_set_template % indicies
		+ enum_infer_template % infers
		+ enum_indexof_template % indexofs
		+ header_end
	)
	return out_text

def enum_to_c(
		atui_data:dict,
		fname:str
		) -> str:
	assert (atui_data["class"] == "enum"), fname
	cfile_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "standard.h"
#include "atomtree.h"
#include "atui.h"
#include "atui_allocator.h"

"""
	enumarray_template:str = """\
struct atui_enum const _atui_enumarray[%u] = {
%s\
};

"""
	enum_template:str = """\
	{
		.name_length = %u,
		.name = "%s",
		.num_entries = %u,
		.description = {%s},
		.enum_array = (struct atui_enum_entry const[%u]) {
%s\
		},
	},
"""
	enum_entry_template:str = """\
			{
				.name = \"%s\",
				.val = %s,
				.name_length = %u,
				.description = {%s},
			},
"""
	enum_entry_assert_template:str = """\
"""
	enum_assert_template:str = """\
static_assert(UINT8_MAX >= ATUI_ENUM(%s).num_entries);
"""

	# main meat
	enum_sets:str = "" # _atui_enumarray members
	enum_entries:str = "" #  struct atui_enum_entry
	entry_name:str = ""
	descr_text:str = ""
	enum:dict
	for enum in atui_data["enums"]:
		enum_entries:str = ""
		enum_entries_asserts:str = ""
		entry:dict
		for entry in enum["constants"]:
			entry_name:str = entry["name"]
			#out_text += enum_entry_assert_template % entry_name
			if "description" in entry:
				descr_text:str = description_to_text(
					entry["description"], "\t\t\t\t"
				)
			else:
				descr_text:str = ""
			enum_entries += enum_entry_template % (
				entry_name, entry_name, len(entry_name), descr_text
			)

		if "description" in enum:
			descr_text:str = description_to_text(enum["description"], "\t\t")
		else:
			descr_text:str = ""
		enum_sets += enum_template % (
			len(enum["name"]), enum["name"], len(enum["constants"]),
			descr_text,
			len(enum["constants"]),
			enum_entries
		)

	#asserts
	enum_asserts:str = ""
	enum_entries_asserts:str = ""
	#for enum in atui_data["enums"]:
	#	enum_asserts += enum_assert_template % enum["name"]

	out_text:str = (
		cfile_header
		+ enumarray_template % (len(atui_data["enums"]), enum_sets)
		+ enum_asserts
	)
	return out_text

class atui_node: pass
class atui_leaf: pass
class atui_branch: pass
class atui_leaf_type:
	# atomtree/atui/atui.h has a copy

	# fancy
	ATUI_NOFANCY:int   = 0
	ATUI_BITFIELD:int  = 1
	ATUI_STRING:int    = 2
	ATUI_ARRAY:int     = 3
	ATUI_GRAFT:int     = 4
	ATUI_SHOOT:int     = 5
	ATUI_PETIOLE:int   = 6
	ATUI_DYNARRAY:int  = 7
	_ATUI_BITCHILD:int = 8
	ATUI_FANCY:tuple = (
		"ATUI_NOFANCY",
		"ATUI_BITFIELD",
		"ATUI_STRING",
		"ATUI_ARRAY",
		"ATUI_GRAFT",
		"ATUI_SHOOT",
		"ATUI_PETIOLE",
		"ATUI_DYNARRAY",
		"_ATUI_BITCHILD",
	)
	FANCIES_THAT_TAKE_RADIX:tuple = (
		ATUI_NOFANCY, ATUI_BITFIELD, ATUI_ARRAY, _ATUI_BITCHILD
	)
	FANCIES_THAT_TAKE_FANCYDATA:tuple = (
		ATUI_BITFIELD, ATUI_GRAFT, ATUI_SHOOT, ATUI_PETIOLE, ATUI_DYNARRAY
	)
	FANCIES_THAT_TAKE_ENUM:tuple = (
		ATUI_NOFANCY, ATUI_BITFIELD, _ATUI_BITCHILD,
	)
	FANCIES_THAT_TAKE_A_BRANCH:tuple = (ATUI_GRAFT, ATUI_SHOOT)
	FANCIES_THAT_HAVE_TRIVIAL_SUBLEAVES:tuple = ( # straightforward
		ATUI_BITFIELD,
	)
	FANCIES_THAT_HAVE_NONTRIVIAL_SUBLEAVES:tuple = ( # requires context
		ATUI_GRAFT, ATUI_PETIOLE, ATUI_DYNARRAY
	)
	FANCIES_THAT_CAN_SUBONLY:tuple = ( # is both a leaf and has subleaves
		ATUI_BITFIELD, ATUI_GRAFT, ATUI_DYNARRAY
	)

	# radix
	ATUI_NAN:int = 0
	ATUI_DEC:int = 1
	ATUI_HEX:int = 2
	ATUI_OCT:int = 3
	ATUI_BIN:int = 4
	ATUI_ANY:int = 7
	ATUI_RADIX:tuple = (
		"ATUI_NAN",
		"ATUI_DEC",
		"ATUI_HEX",
		"ATUI_OCT",
		"ATUI_BIN",
	)

	# disable
	ATUI_DISPLAY:int   = 0
	ATUI_SUBONLY:int   = 1
	ATUI_NODISPLAY:int = 2
	ATUI_DISABLE:tuple = (
		"ATUI_DISPLAY",
		"ATUI_SUBONLY",
		"ATUI_NODISPLAY",
	)

	fancy:int = None
	radix:int = None
	disable:int = None
	# signed ~ enum may be handled through C generics so usually False
	signed_num:str = None
	fraction:str = None
	has_enum:str = None

class atui_children:
	nodes:list # of atui_leaf
	indirect:bool = None
	expanded:bool = None
	def __init__(self
			):
		self.nodes = []
	
class atui_node:
	parent:atui_node = None

	name:str = None
	description:dict = None
	access:str = None # a pointer to the data/var
	access_meta:str = None # for c preprocessor stuff
	num_bytes:str = None
	fancy_data:any = None # "vestige" stuff; atui_branch, dict, str

	def __init__(self,
			node:dict,
			default:dict,
			parent:atui_node
			):
		self.parent = parent
		self.leaves:atui_children = atui_children()
		self.leaves.expanded = True # TODO expose to json5?

		if "name" in node:
			self.name = node["name"]
		elif "name" in default:
			self.name = default["name"]

		if "description" in node:
			self.description = node["description"]
		elif "description" in default:
			self.description = default["description"]

		if "access" in node:
			self.access = node["access"]
		elif "access" in default:
			self.access = default["access"]
		if "NULL" == self.access: # briefly unset access for easier logic
			self.access = None

		if "access_meta" in node:
			self.access_meta = node["access_meta"]
		elif "access_meta" in default:
			self.access_meta = default["access_meta"]
		elif None is not self.access:
			self.access_meta = self.access

		if "num_bytes" in node:
			self.num_bytes = node["num_bytes"]
		elif "num_bytes" in default:
			self.num_bytes = default["num_bytes"]
		elif self.access_meta:
			self.num_bytes = "sizeof(%s)" % self.access_meta
		else:
			self.num_bytes = "0"
	def to_path(self):
		node = self
		path = ""
		while (node):
			path = "/" + node.name + path
			node = node.parent
		return path

	def copy(self):
		return copy.deepcopy(self)
	def compile_display_flags(self):
		# handle the concequences of ATUI_NODISPLAY and ATUI_SUBONLY
		leaves:list = self.leaves.nodes
		i:int = 0
		while (i < len(leaves)):
			leaf:atui_leaf = leaves[i]
			match (leaf.type.disable):
				case atui_leaf_type.ATUI_DISPLAY:
					if leaf.leaves.nodes:
						leaf.compile_display_flags()
					i += 1
				case atui_leaf_type.ATUI_SUBONLY:
					is_trivial:bool = (
						leaf.type.fancy
						in atui_leaf_type.FANCIES_THAT_HAVE_TRIVIAL_SUBLEAVES
					)
					if is_trivial:
						leaves.pop(i)
						leaves = leaves[:i] + leaf.leaves.nodes + leaves[i:]
					else:
						i += 1
				case atui_leaf_type.ATUI_NODISPLAY:
					leaves.pop(i)
		self.leaves.nodes = leaves


class atui_leaf_type_text:
	fancy:str = None
	radix:str = None
	disable:str = None
	signed_num:str = None
	fraction:str = None
	has_enum:str = None

	def __init__(self,
			leaf:atui_leaf
			):
		self.fancy = atui_leaf_type.ATUI_FANCY[leaf.type.fancy]
		self.radix = atui_leaf_type.ATUI_RADIX[leaf.type.radix]
		self.disable = atui_leaf_type.ATUI_DISABLE[leaf.type.disable]
		self.signed_num = "_PPATUI_LEAF_SIGNED(%s)" % leaf.access_meta
		self.fraction = "_PPATUI_LEAF_FRACTION(%s)" % leaf.access_meta
		self.has_enum = "false"
		if (True == leaf.type.signed_num):
			self.signed_num = "true"
		if (True == leaf.type.fraction):
			self.fraction = "true"
		if (True == leaf.type.has_enum):
			# would be as simple as signed or fraction, but c _Generic() has
			# limitations around enums
			self.has_enum = "true"

class atui_leaf(atui_node):
	# the python atui_leaf/atui_branch employs nonbinary logic where None is
	# unknown

	type:atui_leaf_type = None

	array_size:str = None
	fractional_bits:str = None
	total_bits:str = None
	enum:str = None # if it has an associated enum

	# the input "access" field for bit children is just the name of the field;
	# bitchild_access is a backup of that field
	bitchild_access:str = None
	union:str = None # bitfield type
	bitfield_hi:str = None
	bitfield_lo:str = None

	dynarray_deferred:bool = None # array of pointers

	def __init__(self,
			leaf:dict,
			defaults:dict,
			leaf_default:dict,
			parent:atui_node
			):
		atui_node.__init__(self, leaf, leaf_default, parent)
		self.__expand_leaf_type(leaf, leaf_default)
		self.__expand_leaf_fancy(leaf, defaults, leaf_default)

		assert(None is not self.name), (
			self.to_path(),
			self.access,
			atui_leaf_type.ATUI_FANCY[self.type.fancy],
			atui_leaf_type.ATUI_RADIX[self.type.radix],
			atui_leaf_type.ATUI_DISABLE[self.type.disable]
		)
	def __expand_leaf_type(self,
			leaf:dict,
			leaf_default:dict
			):
		self.type:atui_leaf_type = atui_leaf_type()
		fancy:str
		if "fancy" in leaf:
			fancy = leaf["fancy"]
		else:
			fancy = leaf_default["fancy"]
		assert (fancy in atui_leaf_type.ATUI_FANCY), (self.to_path(), fancy)
		self.type.fancy = atui_leaf_type.ATUI_FANCY.index(fancy)

		display = None
		if "display" in leaf:
			display = leaf["display"]
		else:
			display = leaf_default["display"]
		if type(display) is str:
			if display in atui_leaf_type.ATUI_RADIX:
				self.type.radix = atui_leaf_type.ATUI_RADIX.index(display)
				self.type.disable = atui_leaf_type.ATUI_DISPLAY
			elif display in atui_leaf_type.ATUI_DISABLE:
				self.type.radix = atui_leaf_type.ATUI_NAN
				self.type.disable = atui_leaf_type.ATUI_DISABLE.index(display)
			else:
				assert(0), (self.to_path(), display)
		elif type(display) is list:
			assert(self.type.fancy in atui_leaf_type.FANCIES_THAT_TAKE_RADIX), (
				self.to_path(), fancy, display
			)
			if "ATUI_SIGNED" in display:
				self.type.signed_num = True
			if "ATUI_ENUM" in display:
				self.type.has_enum = True
			radix:str = None
			disable:str = None
			for flag in display:
				if flag in atui_leaf_type.ATUI_RADIX:
					radix = flag
				elif flag in atui_leaf_type.ATUI_DISABLE:
					disable = flag
			assert(radix in atui_leaf_type.ATUI_RADIX), (self.to_path(), radix)
			self.type.radix = atui_leaf_type.ATUI_RADIX.index(radix)
			if disable:
				assert(disable in atui_leaf_type.ATUI_DISABLE), self.to_path()
				self.type.disable = atui_leaf_type.ATUI_DISABLE.index(disable)
			else:
				self.type.disable = atui_leaf_type.ATUI_DISPLAY
		else:
			assert(0), (self.to_path(), display)
		assert(None is not self.type.disable), self.to_path()
		subonly_sanity_check:bool = (
			(atui_leaf_type.ATUI_SUBONLY != self.type.disable)
			or (self.type.fancy in atui_leaf_type.FANCIES_THAT_CAN_SUBONLY)
		)
		assert(subonly_sanity_check), self.to_path()
		enum_sanity_check:bool = (
			(not self.type.has_enum)
			or (
				self.type.has_enum
				and (self.type.fancy in atui_leaf_type.FANCIES_THAT_TAKE_ENUM)
			)
		)
		assert (enum_sanity_check), "%s (a %s) can't have an enum" % (
			self.to_path(), atui_leaf_type.ATUI_FANCY[self.type.fancy]
		)
	def __expand_leaf_fancy(self,
			leaf:dict,
			defaults:dict,
			leaf_default:dict
			):
		# __expand_leaf_fancy requires 3 stages to fully churn out the
		# appropriate strings
		# stage 0; easy stuff that will get replaced
		self.array_size = "1"

		# stage 1; fancy-dependent 
		fancy_data:dict = None
		if self.type.fancy in atui_leaf_type.FANCIES_THAT_TAKE_FANCYDATA:
			if "fancy_data" in leaf:
				fancy_data = leaf["fancy_data"]
			else:
				fancy_data = leaf_default["fancy_data"]
		match (self.type.fancy): # TODO hoist each block into its own func?
			case atui_leaf_type.ATUI_NOFANCY:
				if self.access:
					self.access = "&(%s)" % self.access
			case atui_leaf_type.ATUI_BITFIELD:
				if self.access:
					self.access = "&(%s)" % self.access
				if "union" in fancy_data:
					self.union = fancy_data["union"]
				else:
					self.union = "typeof(*bios)"

				bitchild_default:dict = (
					defaults["leaf_defaults"]["bitchild"].copy()
				)
				# _ATUI_BITCHILD should be set automatically by
				# branches_populate_defaults
				bitchild_default["access_meta"] = self.access_meta # c generics
				bitchild_default["union"] = self.union
				fields:list = self.leaves.nodes
				ld:dict
				for ld in fancy_data["fields"]:
					fields.append(atui_leaf(
						ld, defaults, bitchild_default, self
					))
			case atui_leaf_type._ATUI_BITCHILD:
				if None is self.name:
					self.name = self.access
				self.bitchild_access:str = self.access
				# bitchild access_meta is incomplete; take parent/bitfield's
				self.access_meta = leaf_default["access_meta"]
				self.access = "&(%s)" % self.access_meta
				self.union = leaf_default["union"]
				bf_hilo:tuple = (self.union, self.bitchild_access)
				self.bitfield_hi = "_PPATUI_BIT_HI(%s, %s)" % bf_hilo
				self.bitfield_lo = "_PPATUI_BIT_LO(%s, %s)" % bf_hilo
			case atui_leaf_type.ATUI_STRING:
				self.access_meta += "[0]"
			case atui_leaf_type.ATUI_ARRAY:
				self.access_meta += "[0]"
				self.array_size = "lengthof(%s)" % self.access
			case atui_leaf_type.ATUI_GRAFT | atui_leaf_type.ATUI_SHOOT:
				if self.access:
					self.access = "&(%s)" % self.access
				self.fancy_data = "_atui_" + fancy_data
			case atui_leaf_type.ATUI_PETIOLE:
				self.fancy_data = atui_branch( # query after atui'ifying
					{
						"c_type": "atui_nullstruct",
						"name": self.name,
						"description": self.description,
						"num_bytes": "0",
						# start and size is handled by C-side branch allocator.
						"leaves": fancy_data
					},
					defaults, self, True
				)
				subleaves:list = self.fancy_data.leaves.nodes
				if (1 == len(subleaves)):
					# copy c_struct of subleaf
					c_type:str = None
					subleaf:atui_leaf = subleaves[0]
					match (subleaf.type.fancy):
						case atui_leaf_type.ATUI_BITFIELD:
							if subleaf.union:
								c_type = subleaf.union
							else:
								c_type = parent_branch.c_type
						case atui_leaf_type.ATUI_GRAFT | atui_leaf_type.ATUI_SHOOT:
							c_type = subleaf.facy_data[len("_atui_"):]
						case atui_leaf_type.ATUI_DYNARRAY:
							pattern = subleaf.leaves.nodes
							copyable_c_type:bool = (
								(1 == len(pattern))
								and (
									pattern[0].type.fancy
									in atui_leaf_type.FANCIES_THAT_TAKE_A_BRANCH
								)
							)
							if copyable_c_type:
								c_type = pattern[0].fancy_data[len("_atui_"):]
						case _:
							pass
					if c_type:
						self.fancy_data.c_type = c_type
			case atui_leaf_type.ATUI_DYNARRAY:
				self.fancy_data = fancy_data
				self.dynarray_deferred = (not self.access) # array of pointers
				if self.dynarray_deferred:
					self.access = fancy_data["deferred"]
					self.access_meta = self.access
				self.access_meta += "[0]"

				dynpattern_default:dict = (
					defaults["leaf_defaults"]["dynpattern"].copy()
				)
				dynpattern_default["access_meta"] = self.access_meta
				# branches_populate_defaults
				pattern:list = self.leaves.nodes
				ld:dict
				for ld in fancy_data["pattern"]:
					pattern.append(atui_leaf(
						ld, defaults, dynpattern_default, self
					))

				if ("enum" in fancy_data) and ("NULL" != fancy_data["enum"]):
					fancy_data["enum"] = "&(ATUI_ENUM(%s))" % fancy_data["enum"]
				else:
					fancy_data["enum"] = "NULL"
				self.num_bytes = "0" # handle in atui_branch_allocator
		# stage 2; leftovers
		if None is self.access:
			self.access = "NULL"
		if None is self.access_meta:
			self.access_meta = "NULL"
		if None is self.fractional_bits:
			self.fractional_bits = "_PPATUI_LEAF_FIXED_FRACTION_BITS(%s)" % (
				self.access_meta
			)
		if None is self.bitfield_hi:
			self.bitfield_hi = "_PPATUI_LEAF_BITNESS(%s) - 1" % self.access_meta
			self.bitfield_lo = "0"
		if None is self.total_bits:
			self.total_bits = "_PPATUI_LEAF_BITNESS(%s)" % self.access_meta

		if self.type.has_enum:
			if "enum" in leaf:
				self.enum = "&(ATUI_ENUM(%s))" % leaf["enum"]
			elif "enum" in leaf_default:
				self.enum = "&(ATUI_ENUM(%s))" % leaf_default["enum"]
			else:
				self.enum = "ATUI_ENUM_INFER(%s)" % self.access_meta
		else:
			self.enum = "NULL"
	def type_to_text(self,
			):
		return atui_leaf_type_text(self) 


class atui_branch(atui_node):
	# the python atui_leaf/atui_branch employs ternary logic: true/false/unknown
	# None is unknown
	c_prefix:str = None
	c_type:str = None
	atomtree:str = None

	def __init__(self,
			branch:dict,
			defaults:dict,
			parent:atui_node,
			populate_leaves:bool
			):
		branch_default:dict = defaults["branch_default"]
		atui_node.__init__(self, branch, branch_default, parent)
		self.branches:atui_children = atui_children()

		if "c_prefix" in branch:
			self.c_prefix = branch["c_prefix"]
		else:
			self.c_prefix = branch_default["c_prefix"]

		if "c_type" in branch:
			self.c_type = branch["c_type"]
		else:
			self.c_type = branch_default["c_type"]
		if None is self.name:
			self.name = self.c_type

		if None is self.access:
			self.access = "NULL"

		if "atomtree" in branch:
			self.atomtree = branch["atomtree"]
		elif "atomtree" in branch_default:
			self.atomtree = branch_default["atomtree"]
		else:
			self.atomtree = "atui_nullstruct"

		if "expanded" in branch:
			self.branches.expanded = branch["expanded"]
		elif "expanded" in branch_default:
			self.branches.expanded = branch_default["expanded"]
		else:
			self.branches.expanded = True

		if "leaves" in branch and populate_leaves:
			leaves:list = self.leaves.nodes
			leaf_default:dict = defaults["leaf_defaults"]["generic"]#.copy()
			ld:dict
			for ld in branch["leaves"]:
				leaves.append(atui_leaf(ld, defaults, leaf_default, self))

def branches_populate_defaults(
		defaults:dict
		):
	# defaults may not explicitly have every intended default catigory, so to
	# avoid existential conflict, create empty dicts.
	default_leaf_types:set = {"generic", "bitchild", "dynpattern"}
	leaves:dict
	if "leaf_defaults" in defaults:
		leaves = defaults["leaf_defaults"]
		leaf:str
		for leaf in leaves:
			default_leaf_types.remove(leaf)
	else:
		leaves = {}
		defaults["leaf_defaults"] = leaves

	name:str
	for name in default_leaf_types:
		leaves[name]:dict = {}
	
	for leaf_type in leaves:
		leaf = leaves[leaf_type]
		if "display" not in leaf:
			leaf["display"] = "ATUI_DISPLAY"
	leaves["bitchild"]["fancy"] = "_ATUI_BITCHILD"
	
	if "branch_default" not in defaults:
		defaults["branch_default"] = {}


def atui_leaf_type_to_text(
		leaf:atui_leaf,
		parent_indent:str
		) -> str:
	assert(isinstance(leaf, atui_leaf)), leaf.to_path()
	indent:str = parent_indent + "\t"
	type_strings:atui_leaf_type_text = leaf.type_to_text()
	type_text:str = (
		"\n"
		+ indent + ".fancy = " + type_strings.fancy + ",\n"
		+ indent + ".radix = " + type_strings.radix + ",\n"
		+ indent + ".disable = " + type_strings.disable + ",\n"
		+ indent + ".signed_num = " + type_strings.signed_num + ",\n"
		+ indent + ".fraction = " + type_strings.fraction + ",\n"
		+ indent + ".has_enum = " + type_strings.has_enum + ",\n"
	+ parent_indent
	)
	return type_text
def atui_leaf_to_text( # vestige is handled in atui_leaf_vestige_to_text
		leaf:atui_leaf,
		parent_indent:str
		) -> str:
	assert(isinstance(leaf, atui_leaf)), leaf.to_path()
	indent:str = parent_indent + "\t"
	leaf_text:str = (
		"\n"
		+ indent + ".type = {"
			+ atui_leaf_type_to_text(leaf, indent) 
		+ "},\n"
		+ indent + ".array_size = " + leaf.array_size + ",\n"
		+ indent + ".fractional_bits = " + leaf.fractional_bits + ",\n"
		+ indent + ".total_bits = " + leaf.total_bits + ",\n"
		+ indent + ".bitfield_hi = " + leaf.bitfield_hi + ",\n"
		+ indent + ".bitfield_lo = " + leaf.bitfield_lo + ",\n"
		+ indent + ".enum_options = " + leaf.enum + ",\n"
	+ parent_indent
	)
	return leaf_text
def atui_leaf_vestige_to_text(
		leaf:atui_leaf,
		parent_indent:str
		) -> str:
	assert(isinstance(leaf, atui_leaf)), leaf
	indent:str = parent_indent + "\t"
	template_prefix:str = "\n" + indent
	leaves_meta:str = (
		template_prefix
		+ ".leaves_meta = & (struct atui_subleaf_meta const) {%s},\n"
		+ parent_indent
	)
	branch_meta:str = (
		template_prefix
		+ ".branch_meta = & (struct atui_branch_meta const) {%s},\n"
		+ parent_indent
	)
	branch_bud:str = template_prefix + ".branch_bud = %s,\n" + parent_indent

	vestige_text:str = ""
	match (leaf.type.fancy):
		case atui_leaf_type.ATUI_DYNARRAY:
			vestige_text = leaves_meta % leaf_to_subleaf(leaf, indent)
		case atui_leaf_type.ATUI_SHOOT | atui_leaf_type.ATUI_GRAFT:
			vestige_text = branch_bud % leaf.fancy_data
		case atui_leaf_type.ATUI_PETIOLE:
			vestige_text = branch_meta % branch_embryo_to_text(
				leaf.fancy_data, indent
			)
	return vestige_text

def atui_branch_to_text(
		branch:atui_branch,
		parent_indent:str
		) -> str:
	assert(isinstance(branch, atui_branch)), leaf
	indent:str = parent_indent + "\t"
	branch_text:str = (
		"\n"
		+ indent + ".branches.indirect = true,\n"
		+ indent + ".branches.expanded = "
			+ str(branch.branches.expanded).lower() + ",\n"
		+ indent + ".prefer_contiguous = (\n"
		+ indent + "	(0 < _PPATUI_NULLPTR_SIZE(*bios))\n"
		+ indent + "	&& (\n"
		+ indent + "		" + branch.num_bytes + "\n"
		+ indent + "		<= _PPATUI_NULLPTR_SIZE(*bios)\n"
		+ indent + "	)\n"
		+ indent + "),\n"
	+ parent_indent
	)
	return branch_text

def atui_node_to_text(
		node:atui_node,
		parent_indent:str
		) -> str:
	assert(isinstance(node, atui_node)), node
	indent:str = parent_indent + "\t"
	child_indent:str = parent_indent + "\t\t"
	node_text_extra:str = ""
	match (node):
		case atui_leaf():
			# hoist vestige setting into node_template?
			node_text_extra += (
				indent + ".leaf = {%s},\n"
				+ indent + ".vestige = {%s},\n"
			) % (
				atui_leaf_to_text(node, indent),
				atui_leaf_vestige_to_text(node, indent),
			)
		case atui_branch():
			node_text_extra += indent + ".branch = {%s},\n" % (
				atui_branch_to_text(node, indent)
			)
		case _:
			assert(0)
	leaves_text:str = "NULL"
	leaf_template:str = "\n" + child_indent + "{%s},"
	if len(node.leaves.nodes):
		leaves_text = "(atui_node const[]) {"
		for leaf in node.leaves.nodes:
			leaves_text += leaf_template % (
				atui_node_to_text(leaf, child_indent)
			)
		leaves_text += "\n" + indent + "}"

	is_leaf_str:str = str(type(node) is atui_leaf).lower()
	node_text:str = (
		"\n"
		+ indent + ".name = \"" + node.name + "\",\n"
		+ indent + ".origname = \"" + node.name + "\",\n"
		+ indent + ".description = {"
			+ description_to_text(node.description, indent)
		+ "},\n"
		+ indent + ".bundled = " + is_leaf_str + ",\n"
		+ indent + ".is_leaf = " + is_leaf_str + ",\n"
		+ indent + ".data.input = " + node.access + ",\n"
		+ indent + ".num_bytes = " + node.num_bytes + ",\n"
		+ node_text_extra
		+ indent + ".leaves.expanded = true,\n"
		+ indent + ".leaves.count = " + str(len(node.leaves.nodes)) + ",\n"
		+ indent + ".leaves.nodes_ro = " + leaves_text + ",\n"
	+ parent_indent
	)
	return node_text

class deep_count_leaves:
	num_leaves:int = 0
	shallow_num_graft:int = 0
	deep_num_graft:int = 0
	num_shoot:int = 0

	dyn_leaves:str = "0"
	deep_dyn_graft:str = "0" # all graft at all, penetrating type.disable
	shallow_dyn_graft:str = "0" # consdiering type.disable
	dyn_shoot:str = "0"

	leaves_str:str = ""
	deep_graft_str:str = ""
	shallow_graft_str:str = ""
	shoot_str:str = ""

	nest_dynarray:str = " + (%s * (%u + %s))"
	final_nest:str = "(%u + %s)"

	def __init__(self,
			leaves:list
			):
		# go through all the leaves, recursively, to develop a string
		l:atui_leaf
		self.num_leaves = len(leaves)
		for l in leaves:
			subonly:bool = (atui_leaf_type.ATUI_SUBONLY == l.type.disable)
			self.num_leaves -= subonly

			match (l.type.fancy):
				case atui_leaf_type.ATUI_BITFIELD:
					# FANCIES_THAT_HAVE_TRIVIAL_SUBLEAVES
					if subonly:
						self.num_leaves += len(l.leaves.nodes)
				case atui_leaf_type.ATUI_GRAFT:
					self.deep_num_graft += 1
					self.shallow_num_graft += subonly
				case atui_leaf_type.ATUI_SHOOT | atui_leaf_type.ATUI_PETIOLE:
					self.num_shoot += 1
					self.num_leaves -= 1
				case atui_leaf_type.ATUI_DYNARRAY:
					# We're in dynarray. The dynarray segments of subcounters
					# will be non-'0' if there is a nested dynarray.
					dynlength:str = l.fancy_data["count"]
					sub = deep_count_leaves(l.leaves.nodes)
					self.deep_dyn_graft += self.nest_dynarray % (
						dynlength, sub.deep_num_graft, sub.deep_dyn_graft
					)
					self.dyn_shoot += self.nest_dynarray % (
						dynlength, sub.num_shoot, sub.dyn_shoot
					)
					if subonly:
						self.dyn_leaves += self.nest_dynarray % (
							dynlength, sub.num_leaves, sub.dyn_leaves
						)
						self.shallow_dyn_graft += self.nest_dynarray % (
							dynlength,
							sub.shallow_num_graft, sub.shallow_dyn_graft
						)
	def to_text(self):
		self.leaves_str = self.final_nest % (self.num_leaves, self.dyn_leaves)
		self.deep_graft_str = self.final_nest % (
			self.deep_num_graft, self.deep_dyn_graft
		)
		self.shallow_graft_str = self.final_nest % (
			self.shallow_num_graft, self.shallow_dyn_graft
		)
		self.shoot_str = self.final_nest % (self.num_shoot, self.dyn_shoot)

def leaf_to_subleaf(
		leaf:atui_leaf,
		parent_indent:str
		) -> str:
	# if a leaf has sub leaves. See also: struct atui_subleaf_meta
	indent:str = parent_indent + "\t"
	bounds_template:str = (
		"\n"
		+ indent + ".element_size = %s,\n"
		+ indent + ".dynarray_length = %s,\n"
		+ indent + ".deferred_start_array = %s,\n"
		+ indent + ".computed_num_leaves = %s * %s,\n"
		+ indent + ".computed_num_graft = %s * %s,\n"
		+ indent + ".enum_taglist = %s,\n"
	+ parent_indent
	)
	bounds_vals:tuple
	counters = deep_count_leaves(leaf.leaves.nodes)
	counters.to_text()
	match (leaf.type.fancy):
		case atui_leaf_type.ATUI_DYNARRAY:
			bounds_vals = (
				"sizeof(%s)" % leaf.access_meta,
				leaf.fancy_data["count"],
				str(leaf.dynarray_deferred).lower(),
				leaf.fancy_data["count"], counters.leaves_str,
				leaf.fancy_data["count"], counters.shallow_graft_str,
				leaf.fancy_data["enum"],
			)
		case _:
			assert(0), (leaf.to_path(), leaf.type.fancy)
	return bounds_template % bounds_vals

def leaves_asserts_to_text(
		leaves:list,
		parent_indent:str
		) -> str:
	# various asserts and static_asserts over the leaves

	bitfield_assert:str = ("""\
	static_assert(sizeof(*(%s)) == sizeof(%s)); // too big
	assert(((sizeof(*(%s))*CHAR_BIT) - 1) == _PPATUI_BIT_HI(%s, %s)); // not filled out
""")
	assert_text:str = ""
	var_meta:str = ""
	leaf:atui_leaf
	for leaf in leaves:
		match (leaf.type.fancy):
			case atui_leaf_type.ATUI_BITFIELD:
				highest_field:atui_leaf = leaf.leaves.nodes[-1]
				assert_text += bitfield_assert % (
					leaf.access, leaf.union,
					leaf.access, leaf.union, highest_field.bitchild_access
				)
	return assert_text


def branch_embryo_to_text(
		branch:atui_branch,
		parent_indent:str
		) -> str:
	indent:str = parent_indent + "\t"
	embryo_template:str = (
		"\n"
		+ indent + ".seed = {%s},\n"
		+ indent + ".computed_num_leaves = %s,\n"
		+ indent + ".computed_num_shallow_graft = %s,\n"
		+ indent + ".computed_num_deep_graft = %s,\n"
		+ indent + ".computed_num_shoot = %s,\n"
	+ parent_indent
	)
	counters = deep_count_leaves(branch.leaves.nodes)
	counters.to_text()
	embryo_text:str = embryo_template % (
		atui_node_to_text(branch, indent),
		counters.leaves_str,
		counters.shallow_graft_str, counters.deep_graft_str,
		counters.shoot_str
	)
	return embryo_text

def branches_to_c(
		atui_data:dict,
		fname:str
		) -> str:
	# atui branches to text meant for a c file
	assert(atui_data["class"] == "branch")
	assert(type(atui_data["branches"]) is list)

	branches:list = []
	branch:atui_branch = None
	defaults:dict = atui_data["global_defaults"]
	branches_populate_defaults(defaults)
	for bd in atui_data["branches"]:
		branch = atui_branch(bd, defaults, None, True)
		branch.compile_display_flags()
		branches.append(branch)

	cfile_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "standard.h"
#include "atomtree.h"
#include "atui.h"
#include "atui_allocator.h"
"""
# These arrays need to be in a function to handle the bios-> and atomtree->
# everywhere. trying to globalise the vars gets annoying real fast.
	branch_template:str = """
atui_node* 
_atui_%s(
		atuifunc_args const* const args
		) {
	%s %s const* const bios = args->bios;
	struct %s const* const atomtree = args->atomtree;

	struct atui_branch_meta const branch_embryo = {%s};

%s\

	assert(branch_embryo.computed_num_leaves < UINT16_MAX);
	assert(branch_embryo.computed_num_deep_graft < UINT8_MAX);
	assert(branch_embryo.computed_num_shoot < UINT8_MAX);

	return atui_branch_allocator(&branch_embryo, args);
}
"""

	dynarray_patterns_text:str = ""
	dynarray_bounds_text:str = ""
	num_graft:int = 0
	num_shoot:int = 0

	out_text:str = cfile_header
	branch:atui_branch
	for branch in branches:
		out_text += branch_template % (
			branch.name, branch.c_prefix, branch.c_type, branch.atomtree,
			branch_embryo_to_text(branch, "\t"),
			leaves_asserts_to_text(branch.leaves.nodes, "\t"),
		)
	return out_text


def branches_to_h(
		atui_data:dict,
		fname:str
		) -> str:
	# c header defines from atui branches
	assert (atui_data["class"] == "branch"), fname
	assert (type(atui_data["branches"]) is list), fname

	header_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

"""
	header_entry:str = """\
atui_node*
_atui_%s(
		atuifunc_args const* args
		);
"""
	header_ender:str = "\n#endif\n"

	out_text:str = header_header % (fname.upper(), fname.upper())
	branch:atui_branch = None
	defaults:dict = atui_data["global_defaults"]
	branches_populate_defaults(defaults)
	bd:dict
	for bd in atui_data["branches"]:
		out_text += header_entry % atui_branch(bd, defaults, None, False).name

	return out_text + header_ender


def parse_args(
		argv:list
		) -> argparse.Namespace:
	parser:argparse.ArgumentParser = argparse.ArgumentParser()
	parser.add_argument("-o", "--output", required=True, nargs=1)
	parser.add_argument("-i", "--inputs", required=True, nargs='*')
	modes = parser.add_mutually_exclusive_group(required=True)
	modes.add_argument("-s", "--source", action="store_true")
	modes.add_argument("-d", "--header", action="store_true")
	return parser.parse_args(argv)
def intend_source(
		atui_data:dict
		) -> Callable:
	assert ("class" in atui_data)
	match (atui_data["class"]):
		case "branch": return branches_to_c
		case "enum": return enum_to_c
		case "array": return array_to_c
		case "searchfield": return searchfield_to_c
		case "pci_id_lut": return pcilut_to_c
		case _: assert 0
def intend_header(
		atui_data:dict
		) -> Callable:
	assert ("class" in atui_data)
	match (atui_data["class"]):
		case "branch": return branches_to_h
		case "enum": return enum_to_h
		case "array": return array_to_h
		case "searchfield": return searchfield_to_h
		case "pci_id_lut": return pcilut_to_h
		case _: assert 0
def get_intent( # cli argument handling
		intent:argparse.Namespace
		) -> Callable:
	if intent.source:
		return intend_source
	elif intent.header:
		return intend_header
	else:
		assert 0

def main(
		argc:int,
		argv:list
		):
	args:argparse.Namespace = parse_args(argv[1:])

	# a function call that returns a function to select which final function to
	# use
	get_mode:Callable = get_intent(args)
	atui_data:dict = {}
	output_text:str = ""
	infile:str
	for infile in args.inputs:
		with open(infile, 'r', encoding="utf-8") as f:
			atui_data = json5.load(f)
		mode_func:Callable = get_mode(atui_data)
		output_text += mode_func(atui_data, pathlib.Path(infile).stem)

	with open(args.output[0], 'w', encoding="utf-8") as f:
		f.write(output_text)

if (__name__ == "__main__"):
	sys.exit(main(len(sys.argv), sys.argv))
