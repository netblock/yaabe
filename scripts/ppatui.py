#!/usr/bin/env python
# -*- coding: utf-8 -*-

# A metaprogramming script that consumes json5 files to produce c source files
# and c header files for atomtree, usually specifically for ATUI.
# see atomtree/atui_tables/README.md for more info on what the inputs are about
# see also atomtree/atui/atui.h and atomtree/atui/ppatui.h

# To generate C source files branches:
# ppatui.py -s -o output.c -i input.json5
# Produce header files of the generated functions:
# ppatui.py -d -o output.h -i input.json5

# To generate header files for the enums:
# ppatui.py -d -o output.h -i input.json5

import sys
import copy
import json5
import pathlib
import argparse
from typing import Callable

def pcilut_to_c(
		atui_data:dict,
		fname:str
		) -> str:
	# see atomtree/pci_id_lut.h
	assert (atui_data["class"] == "pci_id_lut"), fname

	unique_ids:set = set()
	card:dict
	for card in atui_data["ids"]:
		part_id:int = ((card["vendor"]<<16) | card["device"])
		# we really shouldn't have two identical cards
		assert (part_id not in unique_ids), part_id
		unique_ids.add(part_id)
	del unique_ids
	pci_id_sorter:function = lambda card: ((card["vendor"]<<16)|card["device"])
	atui_data["ids"].sort(key=pci_id_sorter)

	cfile_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "standard.h"
#include "pci_id_lut.h"

struct atomtree_pci_id const %s[%u] = {
%s\
};
static_assert(%u < INT16_MAX); // reserve sign as flag for register_set_bsearch
"""
	entry_template:str = """\
	{
		.ids.vendor = 0x%04X, .ids.device = 0x%04X, .chip = %s,
%s\
	},
"""
	feature_flags:dict = {
		"MOBILITY":     "\t\t.flags.mobility = true,\n",
		"APU":          "\t\t.flags.APU = true,\n",
		"ACPI_ATPX":    "\t\t.flags.ACPI_ATPX = true,\n",
		"EXPERIMENTAL": "\t\t.flags.experimental_hw = true,\n",
		"SINGLE_CRTC":  "\t\t.flags.single_CRTC = true,\n",
		"AGP":          "\t\t.flags.AGP = true,\n",
		"IGPGART":      "\t\t.flags.igpgart = true,\n",
		"PCIe":         "\t\t.flags.PCIe = true,\n",
		"NEW_MEMMAP":   "\t\t.flags.new_memmap = true,\n",
		"PCI":          "\t\t.flags.PCI = true,\n",
	}
	entries_text:str = ""
	card:dict
	for card in atui_data["ids"]:
		flags_text:str = ""
		if "flags" in card:
			flag:str
			for flag in card["flags"]:
				flags_text += feature_flags[flag]
		entries_text += entry_template % (
			card["vendor"], card["device"], card["chip"],
			flags_text
		)
	out_text:str = cfile_header % (
		fname.lower(), len(atui_data["ids"]),
		entries_text,
		len(atui_data["ids"]),
	)
	return out_text
def pcilut_to_h(
		atui_data:dict,
		fname:str
		) -> str:
	assert (atui_data["class"] == "pci_id_lut"), fname
	header_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H
extern struct atomtree_pci_id const %s[%u];
#endif
"""
	out_text:str = header_header % (
		fname.upper(), fname.upper(),
		fname.lower(), len(atui_data["ids"]),
	)
	return out_text


def description_to_text(
		description:dict,
		indent:str
		) -> str:
	# description segment meant for a segment of a c file
	#indended to be used like
	# ".description = {%s}" % description_to_text(...)
	if (description is None):
		return ""
	lang_type:str = ""
	languages:tuple = ("english",)
	descriptions:list = [None,]
	descr_index:int = 0
	trans:dict
	for trans in description:
		descr_index:int = languages.index(trans["language"])
		descriptions[descr_index]:str = trans["text"]

	child_indent:str = indent + "\t"
	descr_template:str = "\n%s" + indent

	des_entry_template:str = child_indent + "\"%s\",\n"
	des_null_entry_template:str = child_indent + "NULL,\n"

	descr_texts:str = ""
	d:str
	for d in descriptions:
		if d:
			descr_texts += des_entry_template % d.replace("\"","\\\"")
		else:
			descr_texts += des_null_entry_template
	return descr_template % descr_texts


def searchfield_to_h(
		atui_data:dict,
		fname:str
		) -> str:
	assert(atui_data["class"] == "searchfield"), fname
	header_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

"""
	field_template:str = "extern struct register_set const %s_reg_set;\n"
	header_end:str = "\n#endif\n"
	out_text:str = header_header % (fname.upper(), fname.upper())
	field:dict
	for field in atui_data["fields"]:
		out_text += field_template % field["name"]
	return out_text + header_end
def searchfield_to_c(
		atui_data:dict,
		fname:str
		) -> str:
	assert(atui_data["class"] == "searchfield"), fname
	cfile_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "standard.h"
#include "atomtree.h"
#include "atui.h"
#include "atui_allocator.h"

"""
	field_template:str = """\
struct register_set const %s_reg_set = {
	.num_reg_set_addresses = %u,
	.set_name = "%s",
	.entries = {
%s\
	},
};
static_assert(%u < INT16_MAX); // reserve sign as flag for register_set_bsearch

"""
	field_entry:str = """\
		{
			.address = %s,
			.index_name = "%s",
			.field_name = "%s",
			.atui_branch_func = _atui_%s,
		},
"""
	out_text:str = cfile_header
	entry_text:str = ""
	num_constants:int = 0
	field:dict
	for field in atui_data["fields"]:
		entry_text:str = ""
		entry:dict
		for entry in field["registers"]:
			index_name:str = entry["index"]
			field_name:str = entry["field"]
			entry_text += field_entry % (
				index_name, index_name,  field_name, field_name
			)
		num_constants:int = len(field["registers"])
		out_text += field_template % (
			field["name"],
			num_constants, field["name"],
			entry_text,
			num_constants, # assert
		)
	return out_text


def array_to_h(
		atui_data:dict,
		fname:str
		) -> str:
	assert (atui_data["class"] == "array"), fname
	header_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

"""
	array_template:str = "extern %s const %s[%u];\n"
	header_end:str = "\n#endif\n"
	out_text:str = header_header % (fname.upper(), fname.upper())
	array:dict
	for array in atui_data["arrays"]:
		out_text += array_template % (
			array["type"], array["name"], len(array["constants"])
		)
	return out_text + header_end
def array_to_c(
		atui_data:dict,
		fname:str
		) -> str:
	assert (atui_data["class"] == "array"), fname
	cfile_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "standard.h"
#include "atomtree.h"

"""
	array_template = """\
%s const %s[%u] = {
%s\
};

"""
	array_entry:str = "\t%s,\n"
	out_text:str = cfile_header
	entry_text:str = ""
	array:dict
	for array in atui_data["arrays"]:
		entry_text:str = ""
		entry:dict
		for entry in array["constants"]:
			entry_text += array_entry % entry
		out_text += array_template % (
			array["type"], array["name"], len(array["constants"]),
			entry_text
		)
	return out_text


def enum_to_h(
		atui_data:dict,
		fname:str
		) -> str:
	assert (atui_data["class"] == "enum"), fname
	header_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

extern struct atui_enum const _atui_enumarray[%u];

"""
	enumarray_indicies_set_template:str = """\
enum enumarray_indicies_set {
%s\
	ATUI_ENUM_ARRAY_LENGTH
};
"""
	enum_index_entry_template:str = "\tATUI_ENUM_INDEX(%s) = %u,\n"
	enum_infer_template:str = """
// cannot be used with non-enums types
#define ATUI_ENUM_INFER(var) _Generic((var),\\
%s\
	default: NULL\\
)
"""
	enum_infer_entry_template:str = "\tenum %s: & ATUI_ENUM(%s),\\\n"
	enum_indexof_template:str = """
// cannot be used with non-enums types
#define ATUI_ENUM_INDEXOF(var) _Generic((var),\\
%s\
	default: ATUI_ENUM_ARRAY_LENGTH\\
)
"""
	enum_indexof_entry_template:str = "\tenum %s: ATUI_ENUM_INDEX(%s),\\\n"
	header_end:str = "\n#endif\n"

	enums:list = atui_data["enums"]
	num_enums:int = len(enums)

	i:int = 0
	indicies:str = ""
	infers:str = ""
	indexofs:str = ""
	while i < num_enums:
		enum:dict = enums[i]
		enum_name:str = enum["name"]
		indicies += enum_index_entry_template % (enum_name, i)
		infers += enum_infer_entry_template % (enum_name, enum_name)
		indexofs +=  enum_indexof_entry_template % (enum_name, enum_name)
		if "aliases" in enum:
			alias:str
			for alias in enum["aliases"]:
				indicies += enum_index_entry_template % (alias, i)
				infers += enum_infer_entry_template % (alias, alias)
				indexofs +=  enum_indexof_entry_template % (alias, alias)
		i += 1

	out_text = (
		header_header % (fname.upper(), fname.upper(), num_enums)
		+ enumarray_indicies_set_template % indicies
		+ enum_infer_template % infers
		+ enum_indexof_template % indexofs
		+ header_end
	)
	return out_text

def enum_to_c(
		atui_data:dict,
		fname:str
		) -> str:
	assert (atui_data["class"] == "enum"), fname
	cfile_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "standard.h"
#include "atomtree.h"
#include "atui.h"
#include "atui_allocator.h"

"""
	enumarray_template:str = """\
struct atui_enum const _atui_enumarray[%u] = {
%s\
};

"""
	enum_template:str = """\
	{
		.name_length = %u,
		.name = "%s",
		.num_entries = %u,
		.description = {%s},
		.enum_array = (struct atui_enum_entry const[%u]) {
%s\
		},
	},
"""
	enum_entry_template:str = """\
			{
				.name = \"%s\",
				.val = %s,
				.name_length = %u,
				.description = {%s},
			},
"""
	enum_entry_assert_template:str = """\
"""
	enum_assert_template:str = """\
static_assert(UINT8_MAX >= ATUI_ENUM(%s).num_entries);
"""

	# main meat
	enum_sets:str = "" # _atui_enumarray members
	enum_entries:str = "" #  struct atui_enum_entry
	entry_name:str = ""
	descr_text:str = ""
	enum:dict
	for enum in atui_data["enums"]:
		enum_entries:str = ""
		enum_entries_asserts:str = ""
		entry:dict
		for entry in enum["constants"]:
			entry_name:str = entry["name"]
			#out_text += enum_entry_assert_template % entry_name
			if "description" in entry:
				descr_text:str = description_to_text(
					entry["description"], "\t\t\t\t"
				)
			else:
				descr_text:str = ""
			enum_entries += enum_entry_template % (
				entry_name, entry_name, len(entry_name), descr_text
			)

		if "description" in enum:
			descr_text:str = description_to_text(enum["description"], "\t\t")
		else:
			descr_text:str = ""
		enum_sets += enum_template % (
			len(enum["name"]), enum["name"], len(enum["constants"]),
			descr_text,
			len(enum["constants"]),
			enum_entries
		)

	#asserts
	enum_asserts:str = ""
	enum_entries_asserts:str = ""
	#for enum in atui_data["enums"]:
	#	enum_asserts += enum_assert_template % enum["name"]

	out_text:str = (
		cfile_header
		+ enumarray_template % (len(atui_data["enums"]), enum_sets)
		+ enum_asserts
	)
	return out_text



class atui_type:
	# atomtree/atui/atui.h has a copy
	# radix
	ATUI_NAN:int = 0x0
	ATUI_DEC:int = 0x1
	ATUI_HEX:int = 0x2
	ATUI_OCT:int = 0x3
	ATUI_BIN:int = 0x4
	ATUI_ANY:int = 0x7
	ATUI_TYPE_RADIX:tuple = (
		"ATUI_NAN",
		"ATUI_DEC",
		"ATUI_HEX",
		"ATUI_OCT",
		"ATUI_BIN",
	)

	# fancy
	ATUI_NOFANCY:int   = 0
	ATUI_BITFIELD:int  = 1
	ATUI_STRING:int    = 2
	ATUI_ARRAY:int     = 3
	ATUI_GRAFT:int     = 4
	ATUI_SHOOT:int     = 5
	ATUI_PETIOLE:int   = 6
	ATUI_DYNARRAY:int  = 7
	_ATUI_BITCHILD:int = 8
	ATUI_TYPE_FANCY:tuple = (
		"ATUI_NOFANCY",
		"ATUI_BITFIELD",
		"ATUI_STRING",
		"ATUI_ARRAY",
		"ATUI_GRAFT",
		"ATUI_SHOOT",
		"ATUI_PETIOLE",
		"ATUI_DYNARRAY",
		"_ATUI_BITCHILD",
	)

	# disable
	ATUI_DISPLAY:int   = 0
	ATUI_SUBONLY:int   = 1
	ATUI_NODISPLAY:int = 2
	ATUI_TYPE_DISABLE:tuple = (
		"ATUI_DISPLAY",
		"ATUI_SUBONLY",
		"ATUI_NODISPLAY",
	)

	radix:int = None
	fancy:int = None
	disable:int = None
	# signed ~ enum may be handled through C generics so usually False
	signed_num:bool = None
	fraction:bool = None
	has_enum:bool = None

class atui_leaf:
	# the python atui_leaf/atui_branch employs ternary logic: true/false/unknown
	# None is unknown
	parent_is_leaf:bool # parent type; meta

	type:atui_type

	access:str # var
	access_meta:str # for c preprocessor stuff
	name:str
	fancy_data:None #dict, str, list, atui_branch
	description:dict
	union:str # bitfield type

	def copy(self):
		return copy.deepcopy(self)

	def __init__(self,
			leaf:dict
			):
		self.parent_is_leaf = False
		self.__expand_leaf_type(leaf)

		leafkeys:set = set(leaf)
		if "access" in leafkeys:
			self.access = leaf["access"]
			self.access_meta = leaf["access"]
		else:
			self.access = None
			self.access_meta = None
		if "name" in leafkeys:
			self.name = leaf["name"]
		else:
			self.name = None

		if "fancy_data" in leafkeys:
			self.fancy_data = leaf["fancy_data"]
		else:
			self.fancy_data = None
		if "description" in leafkeys:
			self.description = leaf["description"]
		else:
			self.description = None
		if "enum" in leafkeys:
			self.enum = leaf["enum"]
		else:
			self.enum = None
		if "union" in leafkeys:
			self.union = leaf["union"]
		else:
			self.union = None
	def __expand_leaf_type(self,
			leaf:dict
			):
		self.type:atui_type = atui_type()
		if "fancy" in leaf:
			assert (leaf["fancy"] in atui_type.ATUI_TYPE_FANCY), (self.name)
			self.type.fancy = atui_type.ATUI_TYPE_FANCY.index(leaf["fancy"])
		if "display" in leaf:
			disp = leaf["display"]
			if type(disp) is str:
				if disp in atui_type.ATUI_TYPE_RADIX:
					self.type.radix = atui_type.ATUI_TYPE_RADIX.index(disp)
					self.type.disable = atui_type.ATUI_DISPLAY
				elif disp in atui_type.ATUI_TYPE_DISABLE:
					self.type.radix = atui_type.ATUI_NAN
					self.type.disable = atui_type.ATUI_TYPE_DISABLE.index(disp)
				else:
					assert(0), (self.name, disp)
			elif type(disp) is list:
				if "ATUI_SIGNED" in disp:
					self.type.signed_num = True
				if "ATUI_ENUM" in disp:
					self.type.has_enum = True
				radix:str = None
				disable:str = None
				for flag in disp:
					if flag in atui_type.ATUI_TYPE_RADIX:
						radix = flag
					elif flag in atui_type.ATUI_TYPE_DISABLE:
						disable = flag
				assert (radix is not None), self.name
				if radix:
					assert(radix in atui_type.ATUI_TYPE_RADIX), self.name
					self.type.radix = atui_type.ATUI_TYPE_RADIX.index(radix)
				if disable:
					assert(disable in atui_type.ATUI_TYPE_DISABLE), self.name
					self.type.disable = (
						atui_type.ATUI_TYPE_DISABLE.index(disable)
					)
			elif disp is None:
				pass
			else:
				assert(0), self.name

class atui_branch:
	# the python atui_leaf/atui_branch employs ternary logic: true/false/unknown
	# None is unknown
	c_prefix:str
	c_type:str
	name:str
	atomtree:str
	description:dict
	table_start:str
	table_size:str
	expanded:bool
	leaves:list

	def copy(self):
		return copy.deepcopy(self)

	def __init__(self,
			branch:dict
			):
		branchkeys:set = set(branch)
		if "c_prefix" in branchkeys:
			self.c_prefix = branch["c_prefix"]
		else:
			self.c_prefix = None
		if "c_type" in branchkeys:
			self.c_type = branch["c_type"]
		else:
			self.c_type = None
		if "atomtree" in branchkeys:
			self.atomtree = branch["atomtree"]
		else:
			self.atomtree = None
		if "name" in branchkeys:
			self.name = branch["name"]
		else:
			self.name = None
		if "description" in branchkeys:
			self.description = branch["description"]
		else:
			self.description = None
		if "table_start" in branchkeys:
			self.table_start = branch["table_start"]
		else:
			self.table_start = None
		if "table_size" in branchkeys:
			self.table_size = branch["table_size"]
		else:
			self.table_size = None
		if "expanded" in branchkeys:
			self.expanded = branch["expanded"]
		else:
			self.expanded = None

		if "leaves" in branchkeys:
			self.leaves = []
			for leaf in branch["leaves"]:
				self.leaves.append(atui_leaf(leaf))
		else:
			self.leaves = None


def populate_branch_defaults(
		defaults:dict
		) -> dict:
	# defaults may not explicitly have every intended attribute, so make them
	# exist with NoneType
	default_leaf_types:set = {"generic", "bitchild", "dynpattern"}
	leaves:dict
	if "leaf_defaults" in defaults:
		leaves = defaults["leaf_defaults"]
		leaf:str
		for leaf in leaves:
			default_leaf_types.remove(leaf)
	else:
		leaves = {}
		defaults["leaf_defaults"] = leaves

	name:str
	for name in default_leaf_types:
		leaves[name]:dict = {}
	
	for leaf_type in leaves:
		leaf = leaves[leaf_type]
		if "display" not in leaf:
			leaf["display"] = "ATUI_DISPLAY"
	

	if not ("branch_defaults" in defaults):
		defaults["branch_defaults"] = {}

	classed_leaves:dict = {}
	leaf:str
	for leaf in leaves:
		classed_leaves[leaf] = atui_leaf(leaves[leaf])
	classed_defaults:dict = {
		"branch_defaults": atui_branch(defaults["branch_defaults"]),
		"leaf_defaults": classed_leaves
	}
	return classed_defaults


def infer_leaf_data(
		defaults:dict,
		leaf_select:str,
		leaves:list
		):
	# infer missing data on a leaf based on what already exists for the leaf 
	# and the global_defaults

	leaf_defaults:dict = defaults["leaf_defaults"]
	leaf_default:atui_leaf = leaf_defaults[leaf_select]

	graftshoot:tuple = (atui_type.ATUI_GRAFT, atui_type.ATUI_SHOOT)

	num_leaves:int = len(leaves)
	i:int = 0
	while i < num_leaves:
		leaf:atui_leaf = leaves[i]

		leaf.parent_is_leaf = leaf_default.parent_is_leaf
		# the various fancy types has different guarantees so we can't assert
		# here
		if leaf.name is None:
			leaf.name = leaf_default.name
		if leaf.access is None:
			leaf.access = leaf_default.access
		if leaf.access_meta is None:
			leaf.access_meta = leaf_default.access_meta
		if leaf.fancy_data is None:
			leaf.fancy_data = leaf_default.fancy_data
		if leaf.description is None:
			leaf.description = leaf_default.description
		if leaf.enum is None:
			leaf.enum = leaf_default.enum
		if leaf.union is None:
			leaf.union = leaf_default.union

		if leaf.type.radix is None:
			leaf.type.radix = leaf_default.type.radix
		assert(type(leaf.type.radix) is int), leaf.name
		if leaf.type.fancy is None:
			leaf.type.fancy = leaf_default.type.fancy
		assert(type(leaf.type.fancy) is int), leaf.name
		if leaf.type.disable is None:
			leaf.type.disable = leaf_default.type.disable
		assert(type(leaf.type.disable) is int), leaf.name
		if leaf.type.signed_num is None:
			leaf.type.signed_num = leaf_default.type.signed_num
		if leaf.type.fraction is None:
			leaf.type.fraction = leaf_default.type.fraction
		if leaf.type.has_enum is None:
			leaf.type.has_enum = leaf_default.type.has_enum


		if leaf.type.disable == atui_type.ATUI_NODISPLAY:
			leaves.remove(leaf) # for loop skips over next
			num_leaves -= 1
			continue

		fancy_data = None
		old_default = None
		child_leaf = None
		access:str = ""
		access_meta:str = ""

		if (leaf.type.has_enum and (leaf.type.fancy not in (
					atui_type.ATUI_NOFANCY,
					atui_type.ATUI_BITFIELD,
					atui_type._ATUI_BITCHILD,
				))):
			assert (0), "%s can't have an enum: %s" % (
				atui_type.ATUI_TYPE_FANCY[leaf.type.fancy], leaf.name
			)

		match (leaf.type.fancy):
			case atui_type.ATUI_BITFIELD:
				fancy_data = copy.copy(leaf.fancy_data)
				fields:list = []
				leaf.fancy_data["fields"] = fields
				l:dict
				for l in fancy_data["fields"]:
					 fields.append(atui_leaf(l))
				if not ("union" in fancy_data):
					leaf.fancy_data["union"] = "typeof(*bios)"

				old_default:atui_leaf = leaf_defaults["bitchild"]
				new_default:atui_leaf = old_default.copy()
				leaf_defaults["bitchild"] = new_default
				#new_default.access = leaf.access # unnecessary
				new_default.access_meta = leaf.access_meta # c generics stuff
				new_default.type.fancy = atui_type._ATUI_BITCHILD
				new_default.parent_is_leaf = True
				new_default.union = leaf.fancy_data["union"]
				infer_leaf_data(defaults, "bitchild", fields)

				leaf_defaults["bitchild"] = old_default
			case atui_type._ATUI_BITCHILD:
				if leaf.name is None:
					leaf.name = leaf.access
				leaf.access_meta = leaf_default.access_meta
			case atui_type.ATUI_ARRAY:
				leaf.access_meta += "[0]"
			case atui_type.ATUI_PETIOLE:
				# TODO hoist atui_leaf'ing the data into the class init.
				# have infer intersect ONLY.
				c_type:str = "atui_nullstruct"
				#if (1 == len(leaf.fancy_data)): # copy c_struct of subleaf
				#	subleaf:atui_leaf = leaf.fancy_data[0]
				#	match (subleaf.type.fancy):
				#		case atui_type.ATUI_BITFIELD:
				#			if "union" in subleaf.fancy_data:
				#				c_type = subleaf.fancy_data["union"]
				#			else:
				#				c_type = parent_branch.c_type
				#		case atui_type.ATUI_GRAFT | atui_type.ATUI_SHOOT:
				#			c_type = subleaf.facy_data[len("_atui_"):]
				#		case atui_type.ATUI_DYNARRAY:
				#			pattern = subleaf.fancy_data["pattern"]
				#			if ((1 == len(pattern)
				#					and (pattern[0].type.fancy in graftshoot)
				#					):
				#				c_type = pattern[0].fancy_data[len("_atui_"):]
				#		case _:
				#			pass
				leaf.fancy_data = atui_branch({
					"c_type": c_type,
					"name": leaf.name,
					"description": leaf.description,
					"table_start": "NULL", "table_size": "0",
					# start and size is handled by C-side branch allocator.
					"leaves": leaf.fancy_data
				})
				infer_branch_data(defaults, leaf.fancy_data, True)
			case atui_type.ATUI_DYNARRAY:
				fancy_data = copy.copy(leaf.fancy_data)
				pattern:list = []
				leaf.fancy_data["pattern"] = pattern
				l:dict
				for l in fancy_data["pattern"]:
					 pattern.append(atui_leaf(l))

				if not ("enum" in leaf.fancy_data):
					leaf.fancy_data["enum"] = "NULL"

				if leaf.access and (leaf.access != "NULL"):
					access_meta = leaf.access_meta # direct array
				else:
					leaf.access_meta = fancy_data["deferred"] + "[0]"
					leaf.access = None
					access_meta = fancy_data["deferred"] # array of pointers
				access_meta += "[0]" # c preprocessor stuff

				old_default = leaf_defaults["dynpattern"]
				new_default = old_default.copy()
				leaf_defaults["dynpattern"] = new_default
				new_default.access_meta = access_meta
				new_default.parent_is_leaf = True
				infer_leaf_data(defaults, "dynpattern", pattern)

				leaf_defaults["dynpattern"] = old_default
		i += 1 # while loop


def infer_branch_data(
		defaults:dict,
		branch:atui_branch,
		infer_leaves:bool=True
		):
	# infer missing data on both the branch elements and all of its leaves,
	# based on what already exists for that branch, and the global_defaults

	branch_defaults:atui_branch = defaults["branch_defaults"]

	if branch.c_prefix is None:
		branch.c_prefix = branch_defaults.c_prefix
	if branch.c_type is None:
		branch.c_type = branch_defaults.c_type
	if branch.atomtree is None:
		branch.atomtree = branch_defaults.atomtree
	if branch.description is None:
		branch.description = branch_defaults.description
	if branch.table_start is None:
		branch.table_start = branch_defaults.table_start
	if branch.table_size is None:
		branch.table_size = branch_defaults.table_size
	if branch.expanded is None:
		branch.expanded = branch_defaults.expanded

	assert (not (branch.c_type is None)), branch.name
	if branch.name is None:
		branch.name = branch.c_type

	if infer_leaves and branch.leaves:
		infer_leaf_data(defaults, "generic", branch.leaves)


def leaf_to_subleaf(
		leaf:atui_leaf,
		indent:str
		) -> str:
	# if a leaf has sub leaves. See also: struct subleaf_meta
	child_indent:str = indent + "\t"
	bounds_template:str = (
"{\n"
+ child_indent + ".element_size = %s,\n"
+ child_indent + ".dynarray_length = %s,\n"
+ child_indent + ".deferred_start_array = %s,\n"
+ child_indent + ".numleaves = %u,\n"
+ child_indent + ".enum_taglist = %s,\n"
+ child_indent + ".sub_leaves = (atui_leaf const[%u]) {\n"
+ "%s"
+ child_indent + "},\n"
+ indent + "},"
)
	bounds_vals:tuple
	match (leaf.type.fancy):
		case atui_type.ATUI_DYNARRAY:
			if leaf.fancy_data["enum"] == "ATUI_NULL":
				enum_taglist = "NULL"
			else:
				enum_taglist = "&(ATUI_ENUM(%s))" % leaf.fancy_data["enum"]
			bounds_vals = (
				"sizeof(%s[0])" % leaf.access_meta,
				leaf.fancy_data["count"],
				str(not leaf.access).lower(),
				len(leaf.fancy_data["pattern"]),
				enum_taglist,
				len(leaf.fancy_data["pattern"]),
				leaves_to_text(leaf.fancy_data["pattern"], child_indent+"\t")
			)
		case atui_type.ATUI_BITFIELD:
			bounds_vals = (
				"0", "0", "0",
				len(leaf.fancy_data["fields"]),
				"NULL",
				len(leaf.fancy_data["fields"]),
				leaves_to_text(leaf.fancy_data["fields"], child_indent+"\t"),
			)
		case _:
			assert 0, (leaf.name, leaf.type.fancy)

	return bounds_template % bounds_vals

def leaf_type_to_text(
		leaftype:list,
		leaf:atui_leaf,
		var_meta:str
		):
	# leaftype:
	# [0] radix,
	# [1] signed_num,
	# [2] fraction,
	# [3] enumtype
	# [4] fancy,
	# [5] disable,
	# [6] enumpointer
	leaftype[0]:str = atui_type.ATUI_TYPE_RADIX[leaf.type.radix]
	leaftype[1]:str = "_PPATUI_LEAF_SIGNED(%s)" % var_meta
	leaftype[2]:str = "_PPATUI_LEAF_FRACTION(%s)" % var_meta
	leaftype[3]:str = "false"
	leaftype[4]:str = atui_type.ATUI_TYPE_FANCY[leaf.type.fancy]
	leaftype[5]:str = atui_type.ATUI_TYPE_DISABLE[leaf.type.disable]
	leaftype[6]:str = "NULL"

	if leaf.type.signed_num is True:
		leaftype[1] = "true"
	if leaf.type.fraction is True:
		leaftype[2] = "true"
	if leaf.type.has_enum is True:
		# would be as simple as signed or fraction, but c _Generic() has
		# limitations around enums
		leaftype[3] = "true"
		if leaf.enum is None:
			leaftype[6] = "ATUI_ENUM_INFER(%s)" % var_meta
		else:
			leaftype[6] = "&(ATUI_ENUM(%s))" % leaf.enum

def leaves_to_text(
		leaves:list,
		indent:str
		) -> str:
	# leaves to text meant for a segment of a c file
	child_indent:str = indent + "\t"
	leaf_template:str = (
indent + "{\n"
+ child_indent + ".name = \"%s\",\n"
+ child_indent + ".origname = \"%s\",\n"

+ child_indent + ".type = {\n"
+ child_indent + "	.radix = %s,\n"
+ child_indent + "	.signed_num = %s,\n"
+ child_indent + "	.fraction = %s,\n"
+ child_indent + "	.has_enum = %s,\n"
+ child_indent + "	.fancy = %s,\n"
+ child_indent + "	.disable = %s,\n"
+ child_indent + "},\n"
+ child_indent + ".enum_options = %s,\n"

+ child_indent + ".num_bytes = _PPATUI_NULLPTR_SIZE(%s),\n"
+ child_indent + ".array_size = 1,\n"
+ child_indent + ".fractional_bits = _PPATUI_LEAF_FIXED_FRACTION_BITS(%s),\n"
+ child_indent + ".total_bits = _PPATUI_LEAF_BITNESS(%s),\n"
+ child_indent + ".bitfield_hi = _PPATUI_LEAF_BITNESS(%s) - 1,\n"

+ child_indent + ".val = %s,\n"
+ child_indent + ".description = {%s},\n"
+ "%s" # extra
+ indent + "},\n"
)

	leaf_text_extra:str = "" # if there is any extra leaf elements
	var_meta:str = ""
	leaves_text:str = ""

	leaftype:list = [
		"radix", "signed_num", "fraction",   "enumtype", "fancy", "disable",
		"enumptr"
	]

	leaf:atui_leaf
	for leaf in leaves: # infer_leaf_data() may have other text gen
		if leaf.access:
			var_access = "&(%s)" % leaf.access
		else:
			var_access = "NULL"
		if leaf.access_meta:
			var_meta = leaf.access_meta
		else:
			var_meta = "NULL"
		match (leaf.type.fancy):
			case atui_type.ATUI_NOFANCY:
				leaf_text_extra = ""
			case atui_type.ATUI_STRING:
				if leaf.access:
					var_access = leaf.access
				leaf_text_extra = ""
			case atui_type.ATUI_ARRAY:
				if leaf.access:
					var_access = leaf.access
				leaf_text_extra = (
					child_indent + ".array_size = lengthof(%s),\n"
					+ child_indent + ".num_bytes = sizeof(%s),\n"
				)
				leaf_text_extra %= (leaf.access, leaf.access)
			case atui_type.ATUI_BITFIELD:
				leaf_text_extra = (
					child_indent + ".num_child_leaves = %u,\n"
					+ child_indent +
						".template_leaves = & (struct subleaf_meta const) %s\n"
				)
				leaf_text_extra %= (
					len(leaf.fancy_data["fields"]),
					leaf_to_subleaf(leaf, child_indent),
				)
			case atui_type._ATUI_BITCHILD:
				leaf_text_extra = (
					child_indent   + ".bitfield_hi = _PPATUI_BIT_HI(%s, %s),\n"
					+ child_indent + ".bitfield_lo = _PPATUI_BIT_LO(%s, %s),\n"
				)
				leaf_text_extra %= (
					leaf.union, leaf.access,
					leaf.union, leaf.access
				)
				var_access = "&(%s)" % leaf.access_meta
			case atui_type.ATUI_SHOOT | atui_type.ATUI_GRAFT: # fallthrough
				leaf_text_extra = (
					child_indent + ".branch_bud = _atui_%s,\n"
				)
				leaf_text_extra %= (leaf.fancy_data,)
			case atui_type.ATUI_DYNARRAY:
				if leaf.access:
					var_meta += "[0]"
					var_access = leaf.access
				else:
					var_access = leaf.fancy_data["deferred"]
				leaf_text_extra = (
					child_indent +
						".template_leaves = & (struct subleaf_meta const) %s\n"
				)
				leaf_text_extra %= (leaf_to_subleaf(leaf, child_indent),)
			case atui_type.ATUI_PETIOLE:
				leaf_text_extra = (
					child_indent
					+ ".template_branch = & (struct atui_branch_data const) {\n"
					+ "%s"
					+ child_indent + "},\n"
				)
				leaf_text_extra %= branch_embryo_to_text(
					leaf.fancy_data, child_indent + "\t"
				)
			case _:
				assert 0, (leaf.name, leaf.fancy)

		if leaf.parent_is_leaf:
			leaf_text_extra += child_indent + ".parent_is_leaf = true,\n"
		leaf.name:str = leaf.name.replace("\"","\\\"")

		leaf_type_to_text(leaftype, leaf, var_meta)

		leaves_text += leaf_template % (
			leaf.name, leaf.name,
			leaftype[0], leaftype[1], leaftype[2], leaftype[3], leaftype[4],
			leaftype[5], # type.disable
			leaftype[6], # enumptr
			var_meta, var_meta, var_meta, var_meta,
			var_access,
			description_to_text(leaf.description, child_indent),
			leaf_text_extra
		)
	return leaves_text

def leaves_asserts_to_text(
		leaves:list,
		indent:str
		) -> str:
	# various asserts and static_asserts over the leaves

	atui_auto_enum_index_assert:str = (
		"	static_assert(ATUI_ENUM_INDEXOF(%s) < ATUI_ENUM_ARRAY_LENGTH);"
		" // enum not registered\n"
	)
	atui_expl_enum_index_assert:str = (
		"	static_assert(ATUI_ENUM_INDEX(%s) < ATUI_ENUM_ARRAY_LENGTH);"
		" // enum not registered\n"
	)
	bitfield_assert:str = """\
	static_assert(sizeof(%s) == sizeof(%s)); // too big
	assert(((sizeof(%s)*CHAR_BIT) - 1) == _PPATUI_BIT_HI(%s, %s)); // not filled out
"""

	assert_text:str = ""
	var_meta:str = ""
	leaf:atui_leaf
	for leaf in leaves:
		if leaf.access_meta:
			var_meta = leaf.access_meta
		else:
			var_meta = "NULL"
		if (leaf.type.has_enum):
			if leaf.enum is None:
				assert_text += atui_auto_enum_index_assert % var_meta
			else:
				assert_text += atui_expl_enum_index_assert % leaf.enum
		match (leaf.type.fancy):
			case atui_type.ATUI_BITFIELD:
				highest_field:atui_leaf = leaf.fancy_data["fields"][-1]
				assert_text += bitfield_assert % (
					leaf.access, leaf.fancy_data["union"],
					leaf.access, leaf.fancy_data["union"], highest_field.access
				)

	return assert_text

def deep_count_leaves_init(
		) -> list:
	counters_template = [0 for i in range(6)]
	for i in range(1,6,2): counters_template[i] = "0"
	return counters_template
def deep_count_leaves(
		counters: list,
		leaves:list
		):
	# go through all the leaves, recursively, to develop a string

	# 0: non-dynarray-pattern leaves
	# 1: dynarray leaves
	# 2: graft
	# 3: dynarray graft
	# 4: shoot
	# 5: dynarray shoot
	counters_template:list = deep_count_leaves_init()
	nest_dynarray:str = "+ (%s * (%u + %s))"
	sub_counters:array = []
	dynlength:str = ""
	counters[0] += len(leaves)
	for leaf in leaves:
		match (leaf.type.fancy):
			case atui_type.ATUI_GRAFT:
				counters[2] += 1
			case atui_type.ATUI_SHOOT | atui_type.ATUI_PETIOLE:
				counters[4] += 1
			#case atui_type.ATUI_BITFIELD:
			#	counters[0] += len(leaf.fancy_data)
			case atui_type.ATUI_DYNARRAY:
				sub_counters = counters_template.copy()
				# We're in dynarray. The dynarray segments of subcounters will
				# be non-'0' if there is a nested dynarray.
				dynlength = leaf.fancy_data["count"]
				deep_count_leaves(sub_counters, leaf.fancy_data["pattern"])
				counters[1] += nest_dynarray % (
					dynlength, sub_counters[0], sub_counters[1]
				)
				counters[3] += nest_dynarray % (
					dynlength, sub_counters[2], sub_counters[3]
				)
				counters[5] += nest_dynarray % (
					dynlength, sub_counters[4], sub_counters[5]
				)

def branch_embryo_to_text(
		branch:atui_branch,
		indent:str
		) -> str:
	child_indent:str = indent + "\t"
	embryo_template:str = (
indent + ".seed = {\n"
+ indent + "	.name = \"%s\",\n"
+ indent + "	.origname = \"%s\",\n"
+ indent + "	.structname = \"%s\",\n"
+ indent + "	.description = {%s},\n"
+ indent + "	.table_start = (void*) (%s),\n"
+ indent + "	.table_size = (%s),\n"
+ indent + "	.prefer_contiguous = (\n"
+ indent + "		(0 < _PPATUI_NULLPTR_SIZE(*bios))\n"
+ indent + "		&& (\n"
+ indent + "			%s\n"
+ indent + "			<= _PPATUI_NULLPTR_SIZE(*bios)\n"
+ indent + "		)\n"
+ indent + "	),\n"
+ indent + "	.expanded = %s,\n"
+ indent + "},\n"
+ indent + ".computed_num_leaves = %s,\n"
+ indent + ".computed_num_graft = %s,\n"
+ indent + ".computed_num_shoot = %s,\n"
+ indent + ".num_leaves_init = %u,\n"
+ indent + ".leaves_init = (atui_leaf const[]) {\n"
+ "%s"
+ indent + "},\n"
)
	counters:list = deep_count_leaves_init()
	deep_count_leaves(counters, branch.leaves)
	embryo_text:str = embryo_template % (
		branch.name, branch.name, branch.c_type, # embryo
		description_to_text(branch.description, child_indent),
		branch.table_start, branch.table_size, branch.table_size,
		str(branch.expanded).lower(),

		"(%u + %s)" % (counters[0], counters[1]), # 'computed'
		"(%u + %s)" % (counters[2], counters[3]),
		"(%u + %s)" % (counters[4], counters[5]),

		len(branch.leaves),  leaves_to_text(branch.leaves, child_indent),
	)
	return embryo_text

def branches_to_c(
		atui_data:dict,
		fname:str
		) -> str:
	# atui branches to text meant for a c file
	assert(atui_data["class"] == "branch")
	assert(type(atui_data["branches"]) is list)

	branches:list = []
	branch:atui_branch = None
	defaults:dict = populate_branch_defaults(atui_data["global_default"])
	for bd in atui_data["branches"]:
		branch = atui_branch(bd)
		infer_branch_data(defaults, branch, True)
		branches.append(branch)

	cfile_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#include "standard.h"
#include "atomtree.h"
#include "atui.h"
#include "atui_allocator.h"
"""
# These arrays need to be in a function to handle the bios-> and atomtree->
# everywhere. trying to globalise the vars gets annoying real fast.
	branch_template:str = """
atui_branch* 
_atui_%s(
		atuifunc_args const* const args
		) {
	%s %s const* const bios = args->bios;
	struct %s const* const atomtree = args->atomtree;

	struct atui_branch_data const branch_embryo = {
%s\
	};

%s\

	assert(branch_embryo.computed_num_leaves < UINT16_MAX);
	assert(branch_embryo.computed_num_graft < UINT8_MAX);
	assert(branch_embryo.computed_num_shoot < UINT8_MAX);

	return atui_branch_allocator(&branch_embryo, args);
}
"""

	dynarray_patterns_text:str = ""
	dynarray_bounds_text:str = ""
	num_graft:int = 0
	num_shoot:int = 0

	# for deep count

	out_text:str = cfile_header
	branch:atui_branch
	for branch in branches:
		out_text += branch_template % (
			branch.name, branch.c_prefix, branch.c_type, branch.atomtree,

			branch_embryo_to_text(branch, "\t\t"),		

			leaves_asserts_to_text(branch.leaves, "\t"),
		)
	return out_text


def branches_to_h(
		atui_data:dict,
		fname:str
		) -> str:
	# c header defines from atui branches
	assert (atui_data["class"] == "branch"), fname
	assert (type(atui_data["branches"]) is list), fname

	header_header:str = """\
/* Autogenerated with ppatui.py. Do not edit. */

#ifndef %s_H
#define %s_H

"""
	header_entry:str = """\
atui_branch*
_atui_%s(
		atuifunc_args const* args
		);
"""
	header_ender:str = "\n#endif\n"

	out_text:str = header_header % (fname.upper(), fname.upper())
	branch:atui_branch = None
	defaults:dict = populate_branch_defaults(atui_data["global_default"])
	bd:dict
	for bd in atui_data["branches"]:
		branch = atui_branch(bd)
		infer_branch_data(defaults, branch, False)
		out_text += header_entry % branch.name

	return out_text + header_ender


def parse_args(
		argv:list
		) -> argparse.Namespace:
	parser:argparse.ArgumentParser = argparse.ArgumentParser()
	parser.add_argument("-o", "--output", required=True, nargs=1)
	parser.add_argument("-i", "--inputs", required=True, nargs='*')
	modes = parser.add_mutually_exclusive_group(required=True)
	modes.add_argument("-s", "--source", action="store_true")
	modes.add_argument("-d", "--header", action="store_true")
	return parser.parse_args(argv)
def intend_source(
		atui_data:dict
		) -> Callable:
	assert ("class" in atui_data)
	match (atui_data["class"]):
		case "branch": return branches_to_c
		case "enum": return enum_to_c
		case "array": return array_to_c
		case "searchfield": return searchfield_to_c
		case "pci_id_lut": return pcilut_to_c
		case _: assert 0
def intend_header(
		atui_data:dict
		) -> Callable:
	assert ("class" in atui_data)
	match (atui_data["class"]):
		case "branch": return branches_to_h
		case "enum": return enum_to_h
		case "array": return array_to_h
		case "searchfield": return searchfield_to_h
		case "pci_id_lut": return pcilut_to_h
		case _: assert 0
def get_intent( # cli argument handling
		intent:argparse.Namespace
		) -> Callable:
	if intent.source:
		return intend_source
	elif intent.header:
		return intend_header
	else:
		assert 0

def main(
		argc:int,
		argv:list
		):
	args:argparse.Namespace = parse_args(argv[1:])

	# a function call that returns a function to select which final function to
	# use
	get_mode:Callable = get_intent(args)
	atui_data:dict = {}
	output_text:str = ""
	infile:str
	for infile in args.inputs:
		with open(infile, 'r', encoding="utf-8") as f:
			atui_data = json5.load(f)
		mode_func:Callable = get_mode(atui_data)
		output_text += mode_func(atui_data, pathlib.Path(infile).stem)

	with open(args.output[0], 'w', encoding="utf-8") as f:
		f.write(output_text)

if (__name__ == "__main__"):
	sys.exit(main(len(sys.argv), sys.argv))
